#!/usr/bin/env python
# @@xxx_skip_license@@
# -*- coding: utf-8 -*-
#
# @PydevCodeAnalysisIgnore
# Generated Fri Feb  5 15:04:13 2016 by generateDS.py version 2.7a.
#

import sys
import getopt
import re as re_
from rogerthat.utils import xml_escape


etree_ = None
Verbose_import_ = False
(XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0',):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

# # from IPython.Shell import IPShellEmbed
# # args = ''
# # ipshell = IPShellEmbed(args,
# #     banner = 'Dropping into IPython',
# #     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name,))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline,)
    else:
        msg = '%s (element %s)' % (msg, node.tag,)
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:  # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:  # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class Attachment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, url=None, contentType=None, name=None, size=None):
        self.url = _cast(None, url)
        self.contentType = _cast(None, contentType)
        self.name = _cast(None, name)
        self.size = _cast(int, size)
        pass
    def factory(*args_, **kwargs_):
        if Attachment.subclass:
            return Attachment.subclass(*args_, **kwargs_)
        else:
            return Attachment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_contentType(self): return self.contentType
    def set_contentType(self, contentType): self.contentType = contentType
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def export(self, outfile, level, namespace_='mstns:', name_='Attachment', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attachment')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='Attachment'):
        if self.url is not None and 'url' not in already_processed:
            already_processed.append('url')
            outfile.write(' url=%s' % (self.gds_format_string(quote_attrib(self.url).encode(ExternalEncoding), input_name='url'),))
        if self.contentType is not None and 'contentType' not in already_processed:
            already_processed.append('contentType')
            outfile.write(' contentType=%s' % (self.gds_format_string(quote_attrib(self.contentType).encode(ExternalEncoding), input_name='contentType'),))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'),))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='Attachment', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attachment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.url is not None and 'url' not in already_processed:
            already_processed.append('url')
            showIndent(outfile, level)
            outfile.write('url = "%s",\n' % (self.url,))
        if self.contentType is not None and 'contentType' not in already_processed:
            already_processed.append('contentType')
            showIndent(outfile, level)
            outfile.write('contentType = "%s",\n' % (self.contentType,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            showIndent(outfile, level)
            outfile.write('size = %d,\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.append('url')
            self.url = value
        value = find_attr_value_('contentType', node)
        if value is not None and 'contentType' not in already_processed:
            already_processed.append('contentType')
            self.contentType = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.append('size')
            try:
                self.size = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Attachment


class FlowElement(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if FlowElement.subclass:
            return FlowElement.subclass(*args_, **kwargs_)
        else:
            return FlowElement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='mstns:', name_='FlowElement', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowElement')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='FlowElement'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='FlowElement', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FlowElement'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FlowElement


class Answer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, action=None, caption=None, id=None, reference=None):
        self.action = _cast(None, action)
        self.caption = _cast(None, caption)
        self.id = _cast(None, id)
        self.reference = _cast(None, reference)
        pass
    def factory(*args_, **kwargs_):
        if Answer.subclass:
            return Answer.subclass(*args_, **kwargs_)
        else:
            return Answer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def export(self, outfile, level, namespace_='mstns:', name_='Answer', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Answer')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='Answer'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (self.gds_format_string(quote_attrib(self.action).encode(ExternalEncoding), input_name='action'),))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'),))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'),))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            outfile.write(' reference=%s' % (self.gds_format_string(quote_attrib(self.reference).encode(ExternalEncoding), input_name='reference'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='Answer', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Answer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = "%s",\n' % (self.action,))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            showIndent(outfile, level)
            outfile.write('reference = "%s",\n' % (self.reference,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            self.reference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Answer


class Message(FlowElement):
    subclass = None
    superclass = FlowElement
    def __init__(self, id=None, alertIntervalType=None, alertType=None, brandingKey=None, allowDismiss=None, vibrate=None, dismissReference=None, autoLock=None, content=None, answer=None, attachment=None):
        super(Message, self).__init__(id,)
        self.alertIntervalType = _cast(None, alertIntervalType)
        self.alertType = _cast(None, alertType)
        self.brandingKey = _cast(None, brandingKey)
        self.allowDismiss = _cast(bool, allowDismiss)
        self.vibrate = _cast(bool, vibrate)
        self.dismissReference = _cast(None, dismissReference)
        self.autoLock = _cast(bool, autoLock)
        self.content = content
        if answer is None:
            self.answer = []
        else:
            self.answer = answer
        if attachment is None:
            self.attachment = []
        else:
            self.attachment = attachment
    def factory(*args_, **kwargs_):
        if Message.subclass:
            return Message.subclass(*args_, **kwargs_)
        else:
            return Message(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_answer(self): return self.answer
    def set_answer(self, answer): self.answer = answer
    def add_answer(self, value): self.answer.append(value)
    def insert_answer(self, index, value): self.answer[index] = value
    def get_attachment(self): return self.attachment
    def set_attachment(self, attachment): self.attachment = attachment
    def add_attachment(self, value): self.attachment.append(value)
    def insert_attachment(self, index, value): self.attachment[index] = value
    def get_alertIntervalType(self): return self.alertIntervalType
    def set_alertIntervalType(self, alertIntervalType): self.alertIntervalType = alertIntervalType
    def validate_AlertIntervalType(self, value):
        # Validate type AlertIntervalType, a restriction on xs:string.
        pass
    def get_alertType(self): return self.alertType
    def set_alertType(self, alertType): self.alertType = alertType
    def validate_AlertType(self, value):
        # Validate type AlertType, a restriction on xs:string.
        pass
    def get_brandingKey(self): return self.brandingKey
    def set_brandingKey(self, brandingKey): self.brandingKey = brandingKey
    def get_allowDismiss(self): return self.allowDismiss
    def set_allowDismiss(self, allowDismiss): self.allowDismiss = allowDismiss
    def get_vibrate(self): return self.vibrate
    def set_vibrate(self, vibrate): self.vibrate = vibrate
    def get_dismissReference(self): return self.dismissReference
    def set_dismissReference(self, dismissReference): self.dismissReference = dismissReference
    def get_autoLock(self): return self.autoLock
    def set_autoLock(self, autoLock): self.autoLock = autoLock
    def export(self, outfile, level, namespace_='mstns:', name_='Message', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Message')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='Message'):
        super(Message, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Message')
        if self.alertIntervalType is not None and 'alertIntervalType' not in already_processed:
            already_processed.append('alertIntervalType')
            outfile.write(' alertIntervalType=%s' % (quote_attrib(self.alertIntervalType),))
        if self.alertType is not None and 'alertType' not in already_processed:
            already_processed.append('alertType')
            outfile.write(' alertType=%s' % (quote_attrib(self.alertType),))
        if self.brandingKey is not None and 'brandingKey' not in already_processed:
            already_processed.append('brandingKey')
            outfile.write(' brandingKey=%s' % (self.gds_format_string(quote_attrib(self.brandingKey).encode(ExternalEncoding), input_name='brandingKey'),))
        if self.allowDismiss is not None and 'allowDismiss' not in already_processed:
            already_processed.append('allowDismiss')
            outfile.write(' allowDismiss="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.allowDismiss)), input_name='allowDismiss'))
        if self.vibrate is not None and 'vibrate' not in already_processed:
            already_processed.append('vibrate')
            outfile.write(' vibrate="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.vibrate)), input_name='vibrate'))
        if self.dismissReference is not None and 'dismissReference' not in already_processed:
            already_processed.append('dismissReference')
            outfile.write(' dismissReference=%s' % (self.gds_format_string(quote_attrib(self.dismissReference).encode(ExternalEncoding), input_name='dismissReference'),))
        if self.autoLock is not None and 'autoLock' not in already_processed:
            already_processed.append('autoLock')
            outfile.write(' autoLock="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.autoLock)), input_name='autoLock'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='Message', fromsubclass_=False):
        super(Message, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.content is not None:
            self.content.export(outfile, level, namespace_, name_='content',)
        for answer_ in self.answer:
            answer_.export(outfile, level, namespace_, name_='answer')
        for attachment_ in self.attachment:
            attachment_.export(outfile, level, namespace_, name_='attachment')
    def hasContent_(self):
        if (
            self.content is not None or
            self.answer or
            self.attachment or
            super(Message, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Message'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.alertIntervalType is not None and 'alertIntervalType' not in already_processed:
            already_processed.append('alertIntervalType')
            showIndent(outfile, level)
            outfile.write('alertIntervalType = "%s",\n' % (self.alertIntervalType,))
        if self.alertType is not None and 'alertType' not in already_processed:
            already_processed.append('alertType')
            showIndent(outfile, level)
            outfile.write('alertType = "%s",\n' % (self.alertType,))
        if self.brandingKey is not None and 'brandingKey' not in already_processed:
            already_processed.append('brandingKey')
            showIndent(outfile, level)
            outfile.write('brandingKey = "%s",\n' % (self.brandingKey,))
        if self.allowDismiss is not None and 'allowDismiss' not in already_processed:
            already_processed.append('allowDismiss')
            showIndent(outfile, level)
            outfile.write('allowDismiss = %s,\n' % (self.allowDismiss,))
        if self.vibrate is not None and 'vibrate' not in already_processed:
            already_processed.append('vibrate')
            showIndent(outfile, level)
            outfile.write('vibrate = %s,\n' % (self.vibrate,))
        if self.dismissReference is not None and 'dismissReference' not in already_processed:
            already_processed.append('dismissReference')
            showIndent(outfile, level)
            outfile.write('dismissReference = "%s",\n' % (self.dismissReference,))
        if self.autoLock is not None and 'autoLock' not in already_processed:
            already_processed.append('autoLock')
            showIndent(outfile, level)
            outfile.write('autoLock = %s,\n' % (self.autoLock,))
        super(Message, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Message, self).exportLiteralChildren(outfile, level, name_)
        if self.content is not None:
            showIndent(outfile, level)
            outfile.write('content=model_.contentType(\n')
            self.content.exportLiteral(outfile, level, name_='content')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('answer=[\n')
        level += 1
        for answer_ in self.answer:
            showIndent(outfile, level)
            outfile.write('model_.Answer(\n')
            answer_.exportLiteral(outfile, level, name_='Answer')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attachment=[\n')
        level += 1
        for attachment_ in self.attachment:
            showIndent(outfile, level)
            outfile.write('model_.Attachment(\n')
            attachment_.exportLiteral(outfile, level, name_='Attachment')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alertIntervalType', node)
        if value is not None and 'alertIntervalType' not in already_processed:
            already_processed.append('alertIntervalType')
            self.alertIntervalType = value
            self.validate_AlertIntervalType(self.alertIntervalType)  # validate type AlertIntervalType
        value = find_attr_value_('alertType', node)
        if value is not None and 'alertType' not in already_processed:
            already_processed.append('alertType')
            self.alertType = value
            self.validate_AlertType(self.alertType)  # validate type AlertType
        value = find_attr_value_('brandingKey', node)
        if value is not None and 'brandingKey' not in already_processed:
            already_processed.append('brandingKey')
            self.brandingKey = value
        value = find_attr_value_('allowDismiss', node)
        if value is not None and 'allowDismiss' not in already_processed:
            already_processed.append('allowDismiss')
            if value in ('true', '1'):
                self.allowDismiss = True
            elif value in ('false', '0'):
                self.allowDismiss = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vibrate', node)
        if value is not None and 'vibrate' not in already_processed:
            already_processed.append('vibrate')
            if value in ('true', '1'):
                self.vibrate = True
            elif value in ('false', '0'):
                self.vibrate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dismissReference', node)
        if value is not None and 'dismissReference' not in already_processed:
            already_processed.append('dismissReference')
            self.dismissReference = value
        value = find_attr_value_('autoLock', node)
        if value is not None and 'autoLock' not in already_processed:
            already_processed.append('autoLock')
            if value in ('true', '1'):
                self.autoLock = True
            elif value in ('false', '0'):
                self.autoLock = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(Message, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = contentType.factory()
            obj_.build(child_)
            self.set_content(obj_)
        elif nodeName_ == 'answer':
            obj_ = Answer.factory()
            obj_.build(child_)
            self.answer.append(obj_)
        elif nodeName_ == 'attachment':
            obj_ = Attachment.factory()
            obj_.build(child_)
            self.attachment.append(obj_)
        super(Message, self).buildChildren(child_, node, nodeName_, True)
# end class Message


class ResultsFlush(FlowElement):
    subclass = None
    superclass = FlowElement
    def __init__(self, id=None, reference=None):
        super(ResultsFlush, self).__init__(id,)
        self.reference = _cast(None, reference)
        pass
    def factory(*args_, **kwargs_):
        if ResultsFlush.subclass:
            return ResultsFlush.subclass(*args_, **kwargs_)
        else:
            return ResultsFlush(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def export(self, outfile, level, namespace_='mstns:', name_='ResultsFlush', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResultsFlush')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='ResultsFlush'):
        super(ResultsFlush, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResultsFlush')
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            outfile.write(' reference=%s' % (self.gds_format_string(quote_attrib(self.reference).encode(ExternalEncoding), input_name='reference'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='ResultsFlush', fromsubclass_=False):
        super(ResultsFlush, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(ResultsFlush, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ResultsFlush'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            showIndent(outfile, level)
            outfile.write('reference = "%s",\n' % (self.reference,))
        super(ResultsFlush, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResultsFlush, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            self.reference = value
        super(ResultsFlush, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ResultsFlush, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ResultsFlush


class ResultsEmail(FlowElement):
    subclass = None
    superclass = FlowElement
    def __init__(self, id=None, reference=None, emailAdmins=None, email=None):
        super(ResultsEmail, self).__init__(id,)
        self.reference = _cast(None, reference)
        self.emailAdmins = _cast(bool, emailAdmins)
        if email is None:
            self.email = []
        else:
            self.email = email
    def factory(*args_, **kwargs_):
        if ResultsEmail.subclass:
            return ResultsEmail.subclass(*args_, **kwargs_)
        else:
            return ResultsEmail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def add_email(self, value): self.email.append(value)
    def insert_email(self, index, value): self.email[index] = value
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def get_emailAdmins(self): return self.emailAdmins
    def set_emailAdmins(self, emailAdmins): self.emailAdmins = emailAdmins
    def export(self, outfile, level, namespace_='mstns:', name_='ResultsEmail', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResultsEmail')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='ResultsEmail'):
        super(ResultsEmail, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResultsEmail')
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            outfile.write(' reference=%s' % (self.gds_format_string(quote_attrib(self.reference).encode(ExternalEncoding), input_name='reference'),))
        if self.emailAdmins is not None and 'emailAdmins' not in already_processed:
            already_processed.append('emailAdmins')
            outfile.write(' emailAdmins="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.emailAdmins)), input_name='emailAdmins'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='ResultsEmail', fromsubclass_=False):
        super(ResultsEmail, self).exportChildren(outfile, level, namespace_, name_, True)
        for email_ in self.email:
            email_.export(outfile, level, namespace_, name_='email')
    def hasContent_(self):
        if (
            self.email or
            super(ResultsEmail, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ResultsEmail'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            showIndent(outfile, level)
            outfile.write('reference = "%s",\n' % (self.reference,))
        if self.emailAdmins is not None and 'emailAdmins' not in already_processed:
            already_processed.append('emailAdmins')
            showIndent(outfile, level)
            outfile.write('emailAdmins = %s,\n' % (self.emailAdmins,))
        super(ResultsEmail, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResultsEmail, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('email=[\n')
        level += 1
        for email_ in self.email:
            showIndent(outfile, level)
            outfile.write('model_.Value(\n')
            email_.exportLiteral(outfile, level, name_='Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            self.reference = value
        value = find_attr_value_('emailAdmins', node)
        if value is not None and 'emailAdmins' not in already_processed:
            already_processed.append('emailAdmins')
            if value in ('true', '1'):
                self.emailAdmins = True
            elif value in ('false', '0'):
                self.emailAdmins = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ResultsEmail, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'email':
            class_obj_ = self.get_class_obj_(child_, Value)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.email.append(obj_)
        super(ResultsEmail, self).buildChildren(child_, node, nodeName_, True)
# end class ResultsEmail


class FlowCode(FlowElement):
    subclass = None
    superclass = FlowElement
    def __init__(self, id=None, exceptionReference=None, outlet=None, javascriptCode=None):
        super(FlowCode, self).__init__(id,)
        self.exceptionReference = _cast(None, exceptionReference)
        if outlet is None:
            self.outlet = []
        else:
            self.outlet = outlet
        self.javascriptCode = javascriptCode
    def factory(*args_, **kwargs_):
        if FlowCode.subclass:
            return FlowCode.subclass(*args_, **kwargs_)
        else:
            return FlowCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_outlet(self): return self.outlet
    def set_outlet(self, outlet): self.outlet = outlet
    def add_outlet(self, value): self.outlet.append(value)
    def insert_outlet(self, index, value): self.outlet[index] = value
    def get_javascriptCode(self): return self.javascriptCode
    def set_javascriptCode(self, javascriptCode): self.javascriptCode = javascriptCode
    def get_exceptionReference(self): return self.exceptionReference
    def set_exceptionReference(self, exceptionReference): self.exceptionReference = exceptionReference
    def export(self, outfile, level, namespace_='mstns:', name_='FlowCode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowCode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='FlowCode'):
        super(FlowCode, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FlowCode')
        if self.exceptionReference is not None and 'exceptionReference' not in already_processed:
            already_processed.append('exceptionReference')
            outfile.write(' exceptionReference=%s' % (self.gds_format_string(quote_attrib(self.exceptionReference).encode(ExternalEncoding), input_name='exceptionReference'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='FlowCode', fromsubclass_=False):
        super(FlowCode, self).exportChildren(outfile, level, namespace_, name_, True)
        for outlet_ in self.outlet:
            outlet_.export(outfile, level, namespace_, name_='outlet')
        if self.javascriptCode is not None:
            self.javascriptCode.export(outfile, level, namespace_, name_='javascriptCode',)
    def hasContent_(self):
        if (
            self.outlet or
            self.javascriptCode is not None or
            super(FlowCode, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FlowCode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.exceptionReference is not None and 'exceptionReference' not in already_processed:
            already_processed.append('exceptionReference')
            showIndent(outfile, level)
            outfile.write('exceptionReference = "%s",\n' % (self.exceptionReference,))
        super(FlowCode, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FlowCode, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('outlet=[\n')
        level += 1
        for outlet_ in self.outlet:
            showIndent(outfile, level)
            outfile.write('model_.Outlet(\n')
            outlet_.exportLiteral(outfile, level, name_='Outlet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.javascriptCode is not None:
            showIndent(outfile, level)
            outfile.write('javascriptCode=model_.javascriptCodeType(\n')
            self.javascriptCode.exportLiteral(outfile, level, name_='javascriptCode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exceptionReference', node)
        if value is not None and 'exceptionReference' not in already_processed:
            already_processed.append('exceptionReference')
            self.exceptionReference = value
        super(FlowCode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'outlet':
            obj_ = Outlet.factory()
            obj_.build(child_)
            self.outlet.append(obj_)
        elif nodeName_ == 'javascriptCode':
            obj_ = javascriptCodeType.factory()
            obj_.build(child_)
            self.set_javascriptCode(obj_)
        super(FlowCode, self).buildChildren(child_, node, nodeName_, True)
# end class FlowCode


class Widget(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Widget.subclass:
            return Widget.subclass(*args_, **kwargs_)
        else:
            return Widget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='mstns:', name_='Widget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Widget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='Widget'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='Widget', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Widget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Widget


class BaseSliderWidget(Widget):
    subclass = None
    superclass = Widget
    def __init__(self, max=None, step=None, precision=None, unit=None, min=None, extensiontype_=None):
        super(BaseSliderWidget, self).__init__(extensiontype_,)
        self.max = _cast(float, max)
        self.step = _cast(float, step)
        self.precision = _cast(int, precision)
        self.unit = _cast(None, unit)
        self.min = _cast(float, min)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if BaseSliderWidget.subclass:
            return BaseSliderWidget.subclass(*args_, **kwargs_)
        else:
            return BaseSliderWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max(self): return self.max
    def set_max(self, max): self.max = max
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_min(self): return self.min
    def set_min(self, min): self.min = min
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='mstns:', name_='BaseSliderWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaseSliderWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='BaseSliderWidget'):
        super(BaseSliderWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BaseSliderWidget')
        if self.max is not None and 'max' not in already_processed:
            already_processed.append('max')
            outfile.write(' max="%s"' % self.gds_format_float(self.max, input_name='max'))
        if self.step is not None and 'step' not in already_processed:
            already_processed.append('step')
            outfile.write(' step="%s"' % self.gds_format_float(self.step, input_name='step'))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.append('precision')
            outfile.write(' precision="%s"' % self.gds_format_integer(self.precision, input_name='precision'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'),))
        if self.min is not None and 'min' not in already_processed:
            already_processed.append('min')
            outfile.write(' min="%s"' % self.gds_format_float(self.min, input_name='min'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='BaseSliderWidget', fromsubclass_=False):
        super(BaseSliderWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(BaseSliderWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BaseSliderWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.max is not None and 'max' not in already_processed:
            already_processed.append('max')
            showIndent(outfile, level)
            outfile.write('max = %f,\n' % (self.max,))
        if self.step is not None and 'step' not in already_processed:
            already_processed.append('step')
            showIndent(outfile, level)
            outfile.write('step = %f,\n' % (self.step,))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.append('precision')
            showIndent(outfile, level)
            outfile.write('precision = %d,\n' % (self.precision,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
        if self.min is not None and 'min' not in already_processed:
            already_processed.append('min')
            showIndent(outfile, level)
            outfile.write('min = %f,\n' % (self.min,))
        super(BaseSliderWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BaseSliderWidget, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.append('max')
            try:
                self.max = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (max): %s' % exp)
        value = find_attr_value_('step', node)
        if value is not None and 'step' not in already_processed:
            already_processed.append('step')
            try:
                self.step = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (step): %s' % exp)
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.append('precision')
            try:
                self.precision = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.append('min')
            try:
                self.min = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (min): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(BaseSliderWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BaseSliderWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseSliderWidget


class SliderWidget(BaseSliderWidget):
    subclass = None
    superclass = BaseSliderWidget
    def __init__(self, max=None, step=None, precision=None, unit=None, min=None, value=None):
        super(SliderWidget, self).__init__(max, step, precision, unit, min,)
        self.value = _cast(float, value)
        pass
    def factory(*args_, **kwargs_):
        if SliderWidget.subclass:
            return SliderWidget.subclass(*args_, **kwargs_)
        else:
            return SliderWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='mstns:', name_='SliderWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SliderWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='SliderWidget'):
        super(SliderWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SliderWidget')
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value="%s"' % self.gds_format_float(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='SliderWidget', fromsubclass_=False):
        super(SliderWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(SliderWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SliderWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %f,\n' % (self.value,))
        super(SliderWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SliderWidget, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            try:
                self.value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        super(SliderWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SliderWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SliderWidget


class RangeSliderWidget(BaseSliderWidget):
    subclass = None
    superclass = BaseSliderWidget
    def __init__(self, max=None, step=None, precision=None, unit=None, min=None, lowValue=None, highValue=None):
        super(RangeSliderWidget, self).__init__(max, step, precision, unit, min,)
        self.lowValue = _cast(float, lowValue)
        self.highValue = _cast(float, highValue)
        pass
    def factory(*args_, **kwargs_):
        if RangeSliderWidget.subclass:
            return RangeSliderWidget.subclass(*args_, **kwargs_)
        else:
            return RangeSliderWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lowValue(self): return self.lowValue
    def set_lowValue(self, lowValue): self.lowValue = lowValue
    def get_highValue(self): return self.highValue
    def set_highValue(self, highValue): self.highValue = highValue
    def export(self, outfile, level, namespace_='mstns:', name_='RangeSliderWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RangeSliderWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='RangeSliderWidget'):
        super(RangeSliderWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RangeSliderWidget')
        if self.lowValue is not None and 'lowValue' not in already_processed:
            already_processed.append('lowValue')
            outfile.write(' lowValue="%s"' % self.gds_format_float(self.lowValue, input_name='lowValue'))
        if self.highValue is not None and 'highValue' not in already_processed:
            already_processed.append('highValue')
            outfile.write(' highValue="%s"' % self.gds_format_float(self.highValue, input_name='highValue'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='RangeSliderWidget', fromsubclass_=False):
        super(RangeSliderWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(RangeSliderWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RangeSliderWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lowValue is not None and 'lowValue' not in already_processed:
            already_processed.append('lowValue')
            showIndent(outfile, level)
            outfile.write('lowValue = %f,\n' % (self.lowValue,))
        if self.highValue is not None and 'highValue' not in already_processed:
            already_processed.append('highValue')
            showIndent(outfile, level)
            outfile.write('highValue = %f,\n' % (self.highValue,))
        super(RangeSliderWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RangeSliderWidget, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lowValue', node)
        if value is not None and 'lowValue' not in already_processed:
            already_processed.append('lowValue')
            try:
                self.lowValue = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (lowValue): %s' % exp)
        value = find_attr_value_('highValue', node)
        if value is not None and 'highValue' not in already_processed:
            already_processed.append('highValue')
            try:
                self.highValue = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (highValue): %s' % exp)
        super(RangeSliderWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RangeSliderWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RangeSliderWidget


class PhotoUploadWidget(Widget):
    subclass = None
    superclass = Widget
    def __init__(self, ratio=None, camera=None, quality=None, gallery=None):
        super(PhotoUploadWidget, self).__init__()
        self.ratio = _cast(None, ratio)
        self.camera = _cast(bool, camera)
        self.quality = _cast(None, quality)
        self.gallery = _cast(bool, gallery)
        pass
    def factory(*args_, **kwargs_):
        if PhotoUploadWidget.subclass:
            return PhotoUploadWidget.subclass(*args_, **kwargs_)
        else:
            return PhotoUploadWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ratio(self): return self.ratio
    def set_ratio(self, ratio): self.ratio = ratio
    def get_camera(self): return self.camera
    def set_camera(self, camera): self.camera = camera
    def get_quality(self): return self.quality
    def set_quality(self, quality): self.quality = quality
    def get_gallery(self): return self.gallery
    def set_gallery(self, gallery): self.gallery = gallery
    def export(self, outfile, level, namespace_='mstns:', name_='PhotoUploadWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotoUploadWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='PhotoUploadWidget'):
        super(PhotoUploadWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PhotoUploadWidget')
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            outfile.write(' ratio=%s' % (self.gds_format_string(quote_attrib(self.ratio).encode(ExternalEncoding), input_name='ratio'),))
        if self.camera is not None and 'camera' not in already_processed:
            already_processed.append('camera')
            outfile.write(' camera="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.camera)), input_name='camera'))
        if self.quality is not None and 'quality' not in already_processed:
            already_processed.append('quality')
            outfile.write(' quality=%s' % (self.gds_format_string(quote_attrib(self.quality).encode(ExternalEncoding), input_name='quality'),))
        if self.gallery is not None and 'gallery' not in already_processed:
            already_processed.append('gallery')
            outfile.write(' gallery="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.gallery)), input_name='gallery'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='PhotoUploadWidget', fromsubclass_=False):
        super(PhotoUploadWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(PhotoUploadWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PhotoUploadWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            showIndent(outfile, level)
            outfile.write('ratio = "%s",\n' % (self.ratio,))
        if self.camera is not None and 'camera' not in already_processed:
            already_processed.append('camera')
            showIndent(outfile, level)
            outfile.write('camera = %s,\n' % (self.camera,))
        if self.quality is not None and 'quality' not in already_processed:
            already_processed.append('quality')
            showIndent(outfile, level)
            outfile.write('quality = "%s",\n' % (self.quality,))
        if self.gallery is not None and 'gallery' not in already_processed:
            already_processed.append('gallery')
            showIndent(outfile, level)
            outfile.write('gallery = %s,\n' % (self.gallery,))
        super(PhotoUploadWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PhotoUploadWidget, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ratio', node)
        if value is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            self.ratio = value
        value = find_attr_value_('camera', node)
        if value is not None and 'camera' not in already_processed:
            already_processed.append('camera')
            if value in ('true', '1'):
                self.camera = True
            elif value in ('false', '0'):
                self.camera = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('quality', node)
        if value is not None and 'quality' not in already_processed:
            already_processed.append('quality')
            self.quality = value
        value = find_attr_value_('gallery', node)
        if value is not None and 'gallery' not in already_processed:
            already_processed.append('gallery')
            if value in ('true', '1'):
                self.gallery = True
            elif value in ('false', '0'):
                self.gallery = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(PhotoUploadWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PhotoUploadWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PhotoUploadWidget


class GPSLocationWidget(Widget):
    subclass = None
    superclass = Widget
    def __init__(self, gps=None):
        super(GPSLocationWidget, self).__init__()
        self.gps = _cast(bool, gps)
        pass
    def factory(*args_, **kwargs_):
        if GPSLocationWidget.subclass:
            return GPSLocationWidget.subclass(*args_, **kwargs_)
        else:
            return GPSLocationWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gps(self): return self.gps
    def set_gps(self, gps): self.gps = gps
    def export(self, outfile, level, namespace_='mstns:', name_='GPSLocationWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GPSLocationWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='GPSLocationWidget'):
        super(GPSLocationWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GPSLocationWidget')
        if self.gps is not None and 'gps' not in already_processed:
            already_processed.append('gps')
            outfile.write(' gps="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.gps)), input_name='gps'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='GPSLocationWidget', fromsubclass_=False):
        super(GPSLocationWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(GPSLocationWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GPSLocationWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.gps is not None and 'gps' not in already_processed:
            already_processed.append('gps')
            showIndent(outfile, level)
            outfile.write('gps = %s,\n' % (self.gps,))
        super(GPSLocationWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GPSLocationWidget, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gps', node)
        if value is not None and 'gps' not in already_processed:
            already_processed.append('gps')
            if value in ('true', '1'):
                self.gps = True
            elif value in ('false', '0'):
                self.gps = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(GPSLocationWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GPSLocationWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GPSLocationWidget


class TextWidget(Widget):
    subclass = None
    superclass = Widget
    def __init__(self, maxChars=None, placeholder=None, value=None, extensiontype_=None):
        super(TextWidget, self).__init__(extensiontype_,)
        self.maxChars = _cast(int, maxChars)
        self.placeholder = _cast(None, placeholder)
        self.value = _cast(None, value)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if TextWidget.subclass:
            return TextWidget.subclass(*args_, **kwargs_)
        else:
            return TextWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maxChars(self): return self.maxChars
    def set_maxChars(self, maxChars): self.maxChars = maxChars
    def get_placeholder(self): return self.placeholder
    def set_placeholder(self, placeholder): self.placeholder = placeholder
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='mstns:', name_='TextWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='TextWidget'):
        super(TextWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TextWidget')
        if self.maxChars is not None and 'maxChars' not in already_processed:
            already_processed.append('maxChars')
            outfile.write(' maxChars="%s"' % self.gds_format_integer(self.maxChars, input_name='maxChars'))
        if self.placeholder is not None and 'placeholder' not in already_processed:
            already_processed.append('placeholder')
            outfile.write(' placeholder=%s' % (self.gds_format_string(quote_attrib(self.placeholder).encode(ExternalEncoding), input_name='placeholder'),))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='TextWidget', fromsubclass_=False):
        super(TextWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(TextWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TextWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.maxChars is not None and 'maxChars' not in already_processed:
            already_processed.append('maxChars')
            showIndent(outfile, level)
            outfile.write('maxChars = %d,\n' % (self.maxChars,))
        if self.placeholder is not None and 'placeholder' not in already_processed:
            already_processed.append('placeholder')
            showIndent(outfile, level)
            outfile.write('placeholder = "%s",\n' % (self.placeholder,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        super(TextWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TextWidget, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxChars', node)
        if value is not None and 'maxChars' not in already_processed:
            already_processed.append('maxChars')
            try:
                self.maxChars = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('placeholder', node)
        if value is not None and 'placeholder' not in already_processed:
            already_processed.append('placeholder')
            self.placeholder = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(TextWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextWidget


class TextLineWidget(TextWidget):
    subclass = None
    superclass = TextWidget
    def __init__(self, maxChars=None, placeholder=None, value=None):
        super(TextLineWidget, self).__init__(maxChars, placeholder, value,)
        pass
    def factory(*args_, **kwargs_):
        if TextLineWidget.subclass:
            return TextLineWidget.subclass(*args_, **kwargs_)
        else:
            return TextLineWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='mstns:', name_='TextLineWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextLineWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='TextLineWidget'):
        super(TextLineWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TextLineWidget')
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='TextLineWidget', fromsubclass_=False):
        super(TextLineWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(TextLineWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TextLineWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TextLineWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TextLineWidget, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TextLineWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextLineWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextLineWidget


class TextBlockWidget(TextWidget):
    subclass = None
    superclass = TextWidget
    def __init__(self, maxChars=None, placeholder=None, value=None):
        super(TextBlockWidget, self).__init__(maxChars, placeholder, value,)
        pass
    def factory(*args_, **kwargs_):
        if TextBlockWidget.subclass:
            return TextBlockWidget.subclass(*args_, **kwargs_)
        else:
            return TextBlockWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='mstns:', name_='TextBlockWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextBlockWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='TextBlockWidget'):
        super(TextBlockWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TextBlockWidget')
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='TextBlockWidget', fromsubclass_=False):
        super(TextBlockWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(TextBlockWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TextBlockWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TextBlockWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TextBlockWidget, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TextBlockWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextBlockWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextBlockWidget


class Value(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, extensiontype_=None):
        self.value = _cast(None, value)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Value.subclass:
            return Value.subclass(*args_, **kwargs_)
        else:
            return Value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='mstns:', name_='Value', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Value')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='Value'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='Value', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Value'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Value


class FloatValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None):
        self.value = _cast(float, value)
        pass
    def factory(*args_, **kwargs_):
        if FloatValue.subclass:
            return FloatValue.subclass(*args_, **kwargs_)
        else:
            return FloatValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='mstns:', name_='FloatValue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatValue')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='FloatValue'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value="%s"' % self.gds_format_float(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='FloatValue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FloatValue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %f,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            try:
                self.value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloatValue


class AdvancedOrderCategory(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, item=None):
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        if item is None:
            self.item = []
        else:
            self.item = item
    def factory(*args_, **kwargs_):
        if AdvancedOrderCategory.subclass:
            return AdvancedOrderCategory.subclass(*args_, **kwargs_)
        else:
            return AdvancedOrderCategory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_item(self): return self.item
    def set_item(self, item): self.item = item
    def add_item(self, value): self.item.append(value)
    def insert_item(self, index, value): self.item[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='mstns:', name_='AdvancedOrderCategory', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdvancedOrderCategory')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='AdvancedOrderCategory'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'),))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='AdvancedOrderCategory', fromsubclass_=False):
        for item_ in self.item:
            item_.export(outfile, level, namespace_, name_='item')
    def hasContent_(self):
        if (
            self.item
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AdvancedOrderCategory'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('item=[\n')
        level += 1
        for item_ in self.item:
            showIndent(outfile, level)
            outfile.write('model_.AdvancedOrderItem(\n')
            item_.exportLiteral(outfile, level, name_='AdvancedOrderItem')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'item':
            obj_ = AdvancedOrderItem.factory()
            obj_.build(child_)
            self.item.append(obj_)
# end class AdvancedOrderCategory


class AdvancedOrderItem(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, stepUnit=None, description=None, stepUnitConversion=None, imageUrl=None, value=None, hasPrice=True, step=None, unitPrice=None, id=None, unit=None, name=None):
        self.stepUnit = _cast(None, stepUnit)
        self.description = _cast(None, description)
        self.stepUnitConversion = _cast(int, stepUnitConversion)
        self.imageUrl = _cast(None, imageUrl)
        self.value = _cast(int, value)
        self.hasPrice = _cast(bool, hasPrice)
        self.step = _cast(int, step)
        self.unitPrice = _cast(int, unitPrice)
        self.id = _cast(None, id)
        self.unit = _cast(None, unit)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if AdvancedOrderItem.subclass:
            return AdvancedOrderItem.subclass(*args_, **kwargs_)
        else:
            return AdvancedOrderItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stepUnit(self): return self.stepUnit
    def set_stepUnit(self, stepUnit): self.stepUnit = stepUnit
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_stepUnitConversion(self): return self.stepUnitConversion
    def set_stepUnitConversion(self, stepUnitConversion): self.stepUnitConversion = stepUnitConversion
    def get_imageUrl(self): return self.imageUrl
    def set_imageUrl(self, imageUrl): self.imageUrl = imageUrl
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_hasPrice(self): return self.hasPrice
    def set_hasPrice(self, hasPrice): self.hasPrice = hasPrice
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def get_unitPrice(self): return self.unitPrice
    def set_unitPrice(self, unitPrice): self.unitPrice = unitPrice
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='mstns:', name_='AdvancedOrderItem', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdvancedOrderItem')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='AdvancedOrderItem'):
        if self.stepUnit is not None and 'stepUnit' not in already_processed:
            already_processed.append('stepUnit')
            outfile.write(' stepUnit=%s' % (self.gds_format_string(quote_attrib(self.stepUnit).encode(ExternalEncoding), input_name='stepUnit'),))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'),))
        if self.stepUnitConversion is not None and 'stepUnitConversion' not in already_processed:
            already_processed.append('stepUnitConversion')
            outfile.write(' stepUnitConversion="%s"' % self.gds_format_integer(self.stepUnitConversion, input_name='stepUnitConversion'))
        if self.imageUrl is not None and 'imageUrl' not in already_processed:
            already_processed.append('imageUrl')
            outfile.write(' imageUrl=%s' % (self.gds_format_string(quote_attrib(self.imageUrl).encode(ExternalEncoding), input_name='imageUrl'),))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
        if self.hasPrice is not None and 'hasPrice' not in already_processed:
            already_processed.append('hasPrice')
            outfile.write(' hasPrice="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.hasPrice)), input_name='hasPrice'))
        if self.step is not None and 'step' not in already_processed:
            already_processed.append('step')
            outfile.write(' step="%s"' % self.gds_format_integer(self.step, input_name='step'))
        if self.unitPrice is not None and 'unitPrice' not in already_processed:
            already_processed.append('unitPrice')
            outfile.write(' unitPrice="%s"' % self.gds_format_integer(self.unitPrice, input_name='unitPrice'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'),))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'),))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='AdvancedOrderItem', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AdvancedOrderItem'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.stepUnit is not None and 'stepUnit' not in already_processed:
            already_processed.append('stepUnit')
            showIndent(outfile, level)
            outfile.write('stepUnit = "%s",\n' % (self.stepUnit,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.stepUnitConversion is not None and 'stepUnitConversion' not in already_processed:
            already_processed.append('stepUnitConversion')
            showIndent(outfile, level)
            outfile.write('stepUnitConversion = %d,\n' % (self.stepUnitConversion,))
        if self.imageUrl is not None and 'imageUrl' not in already_processed:
            already_processed.append('imageUrl')
            showIndent(outfile, level)
            outfile.write('imageUrl = "%s",\n' % (self.imageUrl,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %d,\n' % (self.value,))
        if self.hasPrice is not None and 'hasPrice' not in already_processed:
            already_processed.append('hasPrice')
            showIndent(outfile, level)
            outfile.write('hasPrice = %s,\n' % (self.hasPrice,))
        if self.step is not None and 'step' not in already_processed:
            already_processed.append('step')
            showIndent(outfile, level)
            outfile.write('step = %d,\n' % (self.step,))
        if self.unitPrice is not None and 'unitPrice' not in already_processed:
            already_processed.append('unitPrice')
            showIndent(outfile, level)
            outfile.write('unitPrice = %d,\n' % (self.unitPrice,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('stepUnit', node)
        if value is not None and 'stepUnit' not in already_processed:
            already_processed.append('stepUnit')
            self.stepUnit = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
        value = find_attr_value_('stepUnitConversion', node)
        if value is not None and 'stepUnitConversion' not in already_processed:
            already_processed.append('stepUnitConversion')
            try:
                self.stepUnitConversion = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('imageUrl', node)
        if value is not None and 'imageUrl' not in already_processed:
            already_processed.append('imageUrl')
            self.imageUrl = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            try:
                self.value = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('hasPrice', node)
        if value is not None and 'hasPrice' not in already_processed:
            already_processed.append('hasPrice')
            if value in ('true', '1'):
                self.hasPrice = True
            elif value in ('false', '0'):
                self.hasPrice = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('step', node)
        if value is not None and 'step' not in already_processed:
            already_processed.append('step')
            try:
                self.step = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('unitPrice', node)
        if value is not None and 'unitPrice' not in already_processed:
            already_processed.append('unitPrice')
            try:
                self.unitPrice = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AdvancedOrderItem


class TextAutocompleteWidget(TextWidget):
    subclass = None
    superclass = TextWidget
    def __init__(self, maxChars=None, placeholder=None, value=None, suggestion=None):
        super(TextAutocompleteWidget, self).__init__(maxChars, placeholder, value,)
        if suggestion is None:
            self.suggestion = []
        else:
            self.suggestion = suggestion
    def factory(*args_, **kwargs_):
        if TextAutocompleteWidget.subclass:
            return TextAutocompleteWidget.subclass(*args_, **kwargs_)
        else:
            return TextAutocompleteWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_suggestion(self): return self.suggestion
    def set_suggestion(self, suggestion): self.suggestion = suggestion
    def add_suggestion(self, value): self.suggestion.append(value)
    def insert_suggestion(self, index, value): self.suggestion[index] = value
    def export(self, outfile, level, namespace_='mstns:', name_='TextAutocompleteWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextAutocompleteWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='TextAutocompleteWidget'):
        super(TextAutocompleteWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TextAutocompleteWidget')
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='TextAutocompleteWidget', fromsubclass_=False):
        super(TextAutocompleteWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        for suggestion_ in self.suggestion:
            suggestion_.export(outfile, level, namespace_, name_='suggestion')
    def hasContent_(self):
        if (
            self.suggestion or
            super(TextAutocompleteWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TextAutocompleteWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TextAutocompleteWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TextAutocompleteWidget, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('suggestion=[\n')
        level += 1
        for suggestion_ in self.suggestion:
            showIndent(outfile, level)
            outfile.write('model_.Value(\n')
            suggestion_.exportLiteral(outfile, level, name_='Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TextAutocompleteWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'suggestion':
            class_obj_ = self.get_class_obj_(child_, Value)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.suggestion.append(obj_)
        super(TextAutocompleteWidget, self).buildChildren(child_, node, nodeName_, True)
# end class TextAutocompleteWidget


class Choice(Value):
    subclass = None
    superclass = Value
    def __init__(self, value=None, label=None):
        super(Choice, self).__init__(value,)
        self.label = _cast(None, label)
        pass
    def factory(*args_, **kwargs_):
        if Choice.subclass:
            return Choice.subclass(*args_, **kwargs_)
        else:
            return Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def export(self, outfile, level, namespace_='mstns:', name_='Choice', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Choice')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='Choice'):
        super(Choice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Choice')
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='Choice', fromsubclass_=False):
        super(Choice, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(Choice, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Choice'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        super(Choice, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Choice, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        super(Choice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Choice, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Choice


class SelectWidget(Widget):
    subclass = None
    superclass = Widget
    def __init__(self, choice=None, extensiontype_=None):
        super(SelectWidget, self).__init__(extensiontype_,)
        if choice is None:
            self.choice = []
        else:
            self.choice = choice
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if SelectWidget.subclass:
            return SelectWidget.subclass(*args_, **kwargs_)
        else:
            return SelectWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_choice(self): return self.choice
    def set_choice(self, choice): self.choice = choice
    def add_choice(self, value): self.choice.append(value)
    def insert_choice(self, index, value): self.choice[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='mstns:', name_='SelectWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SelectWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='SelectWidget'):
        super(SelectWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SelectWidget')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='SelectWidget', fromsubclass_=False):
        super(SelectWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        for choice_ in self.choice:
            choice_.export(outfile, level, namespace_, name_='choice')
    def hasContent_(self):
        if (
            self.choice or
            super(SelectWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SelectWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SelectWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SelectWidget, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('choice=[\n')
        level += 1
        for choice_ in self.choice:
            showIndent(outfile, level)
            outfile.write('model_.Choice(\n')
            choice_.exportLiteral(outfile, level, name_='Choice')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(SelectWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'choice':
            obj_ = Choice.factory()
            obj_.build(child_)
            self.choice.append(obj_)
        super(SelectWidget, self).buildChildren(child_, node, nodeName_, True)
# end class SelectWidget


class SelectSingleWidget(SelectWidget):
    subclass = None
    superclass = SelectWidget
    def __init__(self, choice=None, value=None):
        super(SelectSingleWidget, self).__init__(choice,)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if SelectSingleWidget.subclass:
            return SelectSingleWidget.subclass(*args_, **kwargs_)
        else:
            return SelectSingleWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='mstns:', name_='SelectSingleWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SelectSingleWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='SelectSingleWidget'):
        super(SelectSingleWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SelectSingleWidget')
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='SelectSingleWidget', fromsubclass_=False):
        super(SelectSingleWidget, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(SelectSingleWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SelectSingleWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        super(SelectSingleWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SelectSingleWidget, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        super(SelectSingleWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SelectSingleWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SelectSingleWidget


class SelectMultiWidget(SelectWidget):
    subclass = None
    superclass = SelectWidget
    def __init__(self, choice=None, value=None):
        super(SelectMultiWidget, self).__init__(choice,)
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if SelectMultiWidget.subclass:
            return SelectMultiWidget.subclass(*args_, **kwargs_)
        else:
            return SelectMultiWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def export(self, outfile, level, namespace_='mstns:', name_='SelectMultiWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SelectMultiWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='SelectMultiWidget'):
        super(SelectMultiWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SelectMultiWidget')
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='SelectMultiWidget', fromsubclass_=False):
        super(SelectMultiWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value')
    def hasContent_(self):
        if (
            self.value or
            super(SelectMultiWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SelectMultiWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SelectMultiWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SelectMultiWidget, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.Value(\n')
            value_.exportLiteral(outfile, level, name_='Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SelectMultiWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, Value)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.value.append(obj_)
        super(SelectMultiWidget, self).buildChildren(child_, node, nodeName_, True)
# end class SelectMultiWidget


class SelectDateWidget(Widget):
    subclass = None
    superclass = Widget
    def __init__(self, minuteInterval=None, maxDate=None, mode=None, date=None, unit=None, minDate=None):
        super(SelectDateWidget, self).__init__()
        self.minuteInterval = _cast(int, minuteInterval)
        self.maxDate = _cast(int, maxDate)
        self.mode = _cast(None, mode)
        self.date = _cast(int, date)
        self.unit = _cast(None, unit)
        self.minDate = _cast(int, minDate)
        pass
    def factory(*args_, **kwargs_):
        if SelectDateWidget.subclass:
            return SelectDateWidget.subclass(*args_, **kwargs_)
        else:
            return SelectDateWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minuteInterval(self): return self.minuteInterval
    def set_minuteInterval(self, minuteInterval): self.minuteInterval = minuteInterval
    def get_maxDate(self): return self.maxDate
    def set_maxDate(self, maxDate): self.maxDate = maxDate
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_minDate(self): return self.minDate
    def set_minDate(self, minDate): self.minDate = minDate
    def export(self, outfile, level, namespace_='mstns:', name_='SelectDateWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SelectDateWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='SelectDateWidget'):
        super(SelectDateWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SelectDateWidget')
        if self.minuteInterval is not None and 'minuteInterval' not in already_processed:
            already_processed.append('minuteInterval')
            outfile.write(' minuteInterval="%s"' % self.gds_format_integer(self.minuteInterval, input_name='minuteInterval'))
        if self.maxDate is not None and 'maxDate' not in already_processed:
            already_processed.append('maxDate')
            outfile.write(' maxDate="%s"' % self.gds_format_integer(self.maxDate, input_name='maxDate'))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'),))
        if self.date is not None and 'date' not in already_processed:
            already_processed.append('date')
            outfile.write(' date="%s"' % self.gds_format_integer(self.date, input_name='date'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'),))
        if self.minDate is not None and 'minDate' not in already_processed:
            already_processed.append('minDate')
            outfile.write(' minDate="%s"' % self.gds_format_integer(self.minDate, input_name='minDate'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='SelectDateWidget', fromsubclass_=False):
        super(SelectDateWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(SelectDateWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SelectDateWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.minuteInterval is not None and 'minuteInterval' not in already_processed:
            already_processed.append('minuteInterval')
            showIndent(outfile, level)
            outfile.write('minuteInterval = %d,\n' % (self.minuteInterval,))
        if self.maxDate is not None and 'maxDate' not in already_processed:
            already_processed.append('maxDate')
            showIndent(outfile, level)
            outfile.write('maxDate = %d,\n' % (self.maxDate,))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            showIndent(outfile, level)
            outfile.write('mode = "%s",\n' % (self.mode,))
        if self.date is not None and 'date' not in already_processed:
            already_processed.append('date')
            showIndent(outfile, level)
            outfile.write('date = %d,\n' % (self.date,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
        if self.minDate is not None and 'minDate' not in already_processed:
            already_processed.append('minDate')
            showIndent(outfile, level)
            outfile.write('minDate = %d,\n' % (self.minDate,))
        super(SelectDateWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SelectDateWidget, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minuteInterval', node)
        if value is not None and 'minuteInterval' not in already_processed:
            already_processed.append('minuteInterval')
            try:
                self.minuteInterval = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maxDate', node)
        if value is not None and 'maxDate' not in already_processed:
            already_processed.append('maxDate')
            try:
                self.maxDate = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            self.mode = value
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.append('date')
            try:
                self.date = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
        value = find_attr_value_('minDate', node)
        if value is not None and 'minDate' not in already_processed:
            already_processed.append('minDate')
            try:
                self.minDate = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(SelectDateWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SelectDateWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SelectDateWidget


class MyDigiPassWidget(Widget):
    subclass = None
    superclass = Widget
    def __init__(self, scope=None):
        super(MyDigiPassWidget, self).__init__()
        self.scope = _cast(None, scope)
        pass
    def factory(*args_, **kwargs_):
        if MyDigiPassWidget.subclass:
            return MyDigiPassWidget.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def export(self, outfile, level, namespace_='mstns:', name_='MyDigiPassWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MyDigiPassWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='MyDigiPassWidget'):
        super(MyDigiPassWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MyDigiPassWidget')
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.append('scope')
            outfile.write(' scope=%s' % (self.gds_format_string(quote_attrib(self.scope).encode(ExternalEncoding), input_name='scope'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='MyDigiPassWidget', fromsubclass_=False):
        super(MyDigiPassWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(MyDigiPassWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MyDigiPassWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.append('scope')
            showIndent(outfile, level)
            outfile.write('scope = "%s",\n' % (self.scope,))
        super(MyDigiPassWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MyDigiPassWidget, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.append('scope')
            self.scope = value
        super(MyDigiPassWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MyDigiPassWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MyDigiPassWidget


class AdvancedOrderWidget(Widget):
    subclass = None
    superclass = Widget
    def __init__(self, currency=None, leapTime=None, category=None):
        super(AdvancedOrderWidget, self).__init__()
        self.currency = _cast(None, currency)
        self.leapTime = _cast(int, leapTime)
        if category is None:
            self.category = []
        else:
            self.category = category
    def factory(*args_, **kwargs_):
        if AdvancedOrderWidget.subclass:
            return AdvancedOrderWidget.subclass(*args_, **kwargs_)
        else:
            return AdvancedOrderWidget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category(self, index, value): self.category[index] = value
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_leapTime(self): return self.leapTime
    def set_leapTime(self, leapTime): self.leapTime = leapTime
    def export(self, outfile, level, namespace_='mstns:', name_='AdvancedOrderWidget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdvancedOrderWidget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='AdvancedOrderWidget'):
        super(AdvancedOrderWidget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AdvancedOrderWidget')
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            outfile.write(' currency=%s' % (self.gds_format_string(quote_attrib(self.currency).encode(ExternalEncoding), input_name='currency'),))
        if self.leapTime is not None and 'leapTime' not in already_processed:
            already_processed.append('leapTime')
            outfile.write(' leapTime="%s"' % self.gds_format_integer(self.leapTime, input_name='leapTime'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='AdvancedOrderWidget', fromsubclass_=False):
        super(AdvancedOrderWidget, self).exportChildren(outfile, level, namespace_, name_, True)
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category')
    def hasContent_(self):
        if (
            self.category or
            super(AdvancedOrderWidget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AdvancedOrderWidget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            showIndent(outfile, level)
            outfile.write('currency = "%s",\n' % (self.currency,))
        if self.leapTime is not None and 'leapTime' not in already_processed:
            already_processed.append('leapTime')
            showIndent(outfile, level)
            outfile.write('leapTime = %d,\n' % (self.leapTime,))
        super(AdvancedOrderWidget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AdvancedOrderWidget, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('category=[\n')
        level += 1
        for category_ in self.category:
            showIndent(outfile, level)
            outfile.write('model_.AdvancedOrderCategory(\n')
            category_.exportLiteral(outfile, level, name_='AdvancedOrderCategory')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            self.currency = value
        value = find_attr_value_('leapTime', node)
        if value is not None and 'leapTime' not in already_processed:
            already_processed.append('leapTime')
            try:
                self.leapTime = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(AdvancedOrderWidget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'category':
            obj_ = AdvancedOrderCategory.factory()
            obj_.build(child_)
            self.category.append(obj_)
        super(AdvancedOrderWidget, self).buildChildren(child_, node, nodeName_, True)
# end class AdvancedOrderWidget


class Form(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, positiveButtonConfirmation=None, negativeButtonCaption=None, positiveButtonCaption=None, negativeButtonConfirmation=None, widget=None, javascriptValidation=None):
        self.positiveButtonConfirmation = _cast(None, positiveButtonConfirmation)
        self.negativeButtonCaption = _cast(None, negativeButtonCaption)
        self.positiveButtonCaption = _cast(None, positiveButtonCaption)
        self.negativeButtonConfirmation = _cast(None, negativeButtonConfirmation)
        self.widget = widget
        self.javascriptValidation = javascriptValidation
    def factory(*args_, **kwargs_):
        if Form.subclass:
            return Form.subclass(*args_, **kwargs_)
        else:
            return Form(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_widget(self): return self.widget
    def set_widget(self, widget): self.widget = widget
    def get_javascriptValidation(self): return self.javascriptValidation
    def set_javascriptValidation(self, javascriptValidation): self.javascriptValidation = javascriptValidation
    def get_positiveButtonConfirmation(self): return self.positiveButtonConfirmation
    def set_positiveButtonConfirmation(self, positiveButtonConfirmation): self.positiveButtonConfirmation = positiveButtonConfirmation
    def get_negativeButtonCaption(self): return self.negativeButtonCaption
    def set_negativeButtonCaption(self, negativeButtonCaption): self.negativeButtonCaption = negativeButtonCaption
    def get_positiveButtonCaption(self): return self.positiveButtonCaption
    def set_positiveButtonCaption(self, positiveButtonCaption): self.positiveButtonCaption = positiveButtonCaption
    def get_negativeButtonConfirmation(self): return self.negativeButtonConfirmation
    def set_negativeButtonConfirmation(self, negativeButtonConfirmation): self.negativeButtonConfirmation = negativeButtonConfirmation
    def export(self, outfile, level, namespace_='mstns:', name_='Form', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Form')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='Form'):
        if self.positiveButtonConfirmation is not None and 'positiveButtonConfirmation' not in already_processed:
            already_processed.append('positiveButtonConfirmation')
            outfile.write(' positiveButtonConfirmation=%s' % (self.gds_format_string(quote_attrib(self.positiveButtonConfirmation).encode(ExternalEncoding), input_name='positiveButtonConfirmation'),))
        if self.negativeButtonCaption is not None and 'negativeButtonCaption' not in already_processed:
            already_processed.append('negativeButtonCaption')
            outfile.write(' negativeButtonCaption=%s' % (self.gds_format_string(quote_attrib(self.negativeButtonCaption).encode(ExternalEncoding), input_name='negativeButtonCaption'),))
        if self.positiveButtonCaption is not None and 'positiveButtonCaption' not in already_processed:
            already_processed.append('positiveButtonCaption')
            outfile.write(' positiveButtonCaption=%s' % (self.gds_format_string(quote_attrib(self.positiveButtonCaption).encode(ExternalEncoding), input_name='positiveButtonCaption'),))
        if self.negativeButtonConfirmation is not None and 'negativeButtonConfirmation' not in already_processed:
            already_processed.append('negativeButtonConfirmation')
            outfile.write(' negativeButtonConfirmation=%s' % (self.gds_format_string(quote_attrib(self.negativeButtonConfirmation).encode(ExternalEncoding), input_name='negativeButtonConfirmation'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='Form', fromsubclass_=False):
        if self.widget is not None:
            self.widget.export(outfile, level, namespace_, name_='widget',)
        if self.javascriptValidation is not None:
            showIndent(outfile, level)
            outfile.write('<%sjavascriptValidation>%s</%sjavascriptValidation>\n' % (namespace_, self.gds_format_string(quote_xml(self.javascriptValidation).encode(ExternalEncoding), input_name='javascriptValidation'), namespace_))
    def hasContent_(self):
        if (
            self.widget is not None or
            self.javascriptValidation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Form'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.positiveButtonConfirmation is not None and 'positiveButtonConfirmation' not in already_processed:
            already_processed.append('positiveButtonConfirmation')
            showIndent(outfile, level)
            outfile.write('positiveButtonConfirmation = "%s",\n' % (self.positiveButtonConfirmation,))
        if self.negativeButtonCaption is not None and 'negativeButtonCaption' not in already_processed:
            already_processed.append('negativeButtonCaption')
            showIndent(outfile, level)
            outfile.write('negativeButtonCaption = "%s",\n' % (self.negativeButtonCaption,))
        if self.positiveButtonCaption is not None and 'positiveButtonCaption' not in already_processed:
            already_processed.append('positiveButtonCaption')
            showIndent(outfile, level)
            outfile.write('positiveButtonCaption = "%s",\n' % (self.positiveButtonCaption,))
        if self.negativeButtonConfirmation is not None and 'negativeButtonConfirmation' not in already_processed:
            already_processed.append('negativeButtonConfirmation')
            showIndent(outfile, level)
            outfile.write('negativeButtonConfirmation = "%s",\n' % (self.negativeButtonConfirmation,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.widget is not None:
            showIndent(outfile, level)
            outfile.write('widget=model_.Widget(\n')
            self.widget.exportLiteral(outfile, level, name_='widget')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.javascriptValidation is not None:
            showIndent(outfile, level)
            outfile.write('javascriptValidation=%s,\n' % quote_python(self.javascriptValidation).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('positiveButtonConfirmation', node)
        if value is not None and 'positiveButtonConfirmation' not in already_processed:
            already_processed.append('positiveButtonConfirmation')
            self.positiveButtonConfirmation = value
        value = find_attr_value_('negativeButtonCaption', node)
        if value is not None and 'negativeButtonCaption' not in already_processed:
            already_processed.append('negativeButtonCaption')
            self.negativeButtonCaption = value
        value = find_attr_value_('positiveButtonCaption', node)
        if value is not None and 'positiveButtonCaption' not in already_processed:
            already_processed.append('positiveButtonCaption')
            self.positiveButtonCaption = value
        value = find_attr_value_('negativeButtonConfirmation', node)
        if value is not None and 'negativeButtonConfirmation' not in already_processed:
            already_processed.append('negativeButtonConfirmation')
            self.negativeButtonConfirmation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'widget':
            class_obj_ = self.get_class_obj_(child_, Widget)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_widget(obj_)
        elif nodeName_ == 'javascriptValidation':
            javascriptValidation_ = child_.text
            javascriptValidation_ = self.gds_validate_string(javascriptValidation_, node, 'javascriptValidation')
            self.javascriptValidation = javascriptValidation_
# end class Form


class FormMessage(FlowElement):
    subclass = None
    superclass = FlowElement
    def __init__(self, id=None, alertIntervalType=None, alertType=None, brandingKey=None, positiveReference=None, vibrate=None, member=None, autoLock=None, negativeReference=None, content=None, form=None, attachment=None):
        super(FormMessage, self).__init__(id,)
        self.alertIntervalType = _cast(None, alertIntervalType)
        self.alertType = _cast(None, alertType)
        self.brandingKey = _cast(None, brandingKey)
        self.positiveReference = _cast(None, positiveReference)
        self.vibrate = _cast(bool, vibrate)
        self.member = _cast(None, member)
        self.autoLock = _cast(bool, autoLock)
        self.negativeReference = _cast(None, negativeReference)
        self.content = content
        self.form = form
        if attachment is None:
            self.attachment = []
        else:
            self.attachment = attachment
    def factory(*args_, **kwargs_):
        if FormMessage.subclass:
            return FormMessage.subclass(*args_, **kwargs_)
        else:
            return FormMessage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_form(self): return self.form
    def set_form(self, form): self.form = form
    def get_attachment(self): return self.attachment
    def set_attachment(self, attachment): self.attachment = attachment
    def add_attachment(self, value): self.attachment.append(value)
    def insert_attachment(self, index, value): self.attachment[index] = value
    def get_alertIntervalType(self): return self.alertIntervalType
    def set_alertIntervalType(self, alertIntervalType): self.alertIntervalType = alertIntervalType
    def validate_AlertIntervalType(self, value):
        # Validate type AlertIntervalType, a restriction on xs:string.
        pass
    def get_alertType(self): return self.alertType
    def set_alertType(self, alertType): self.alertType = alertType
    def validate_AlertType(self, value):
        # Validate type AlertType, a restriction on xs:string.
        pass
    def get_brandingKey(self): return self.brandingKey
    def set_brandingKey(self, brandingKey): self.brandingKey = brandingKey
    def get_positiveReference(self): return self.positiveReference
    def set_positiveReference(self, positiveReference): self.positiveReference = positiveReference
    def get_vibrate(self): return self.vibrate
    def set_vibrate(self, vibrate): self.vibrate = vibrate
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def get_autoLock(self): return self.autoLock
    def set_autoLock(self, autoLock): self.autoLock = autoLock
    def get_negativeReference(self): return self.negativeReference
    def set_negativeReference(self, negativeReference): self.negativeReference = negativeReference
    def export(self, outfile, level, namespace_='mstns:', name_='FormMessage', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FormMessage')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='FormMessage'):
        super(FormMessage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FormMessage')
        if self.alertIntervalType is not None and 'alertIntervalType' not in already_processed:
            already_processed.append('alertIntervalType')
            outfile.write(' alertIntervalType=%s' % (quote_attrib(self.alertIntervalType),))
        if self.alertType is not None and 'alertType' not in already_processed:
            already_processed.append('alertType')
            outfile.write(' alertType=%s' % (quote_attrib(self.alertType),))
        if self.brandingKey is not None and 'brandingKey' not in already_processed:
            already_processed.append('brandingKey')
            outfile.write(' brandingKey=%s' % (self.gds_format_string(quote_attrib(self.brandingKey).encode(ExternalEncoding), input_name='brandingKey'),))
        if self.positiveReference is not None and 'positiveReference' not in already_processed:
            already_processed.append('positiveReference')
            outfile.write(' positiveReference=%s' % (self.gds_format_string(quote_attrib(self.positiveReference).encode(ExternalEncoding), input_name='positiveReference'),))
        if self.vibrate is not None and 'vibrate' not in already_processed:
            already_processed.append('vibrate')
            outfile.write(' vibrate="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.vibrate)), input_name='vibrate'))
        if self.member is not None and 'member' not in already_processed:
            already_processed.append('member')
            outfile.write(' member=%s' % (self.gds_format_string(quote_attrib(self.member).encode(ExternalEncoding), input_name='member'),))
        if self.autoLock is not None and 'autoLock' not in already_processed:
            already_processed.append('autoLock')
            outfile.write(' autoLock="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.autoLock)), input_name='autoLock'))
        if self.negativeReference is not None and 'negativeReference' not in already_processed:
            already_processed.append('negativeReference')
            outfile.write(' negativeReference=%s' % (self.gds_format_string(quote_attrib(self.negativeReference).encode(ExternalEncoding), input_name='negativeReference'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='FormMessage', fromsubclass_=False):
        super(FormMessage, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.content is not None:
            self.content.export(outfile, level, namespace_, name_='content',)
        if self.form is not None:
            self.form.export(outfile, level, namespace_, name_='form',)
        for attachment_ in self.attachment:
            attachment_.export(outfile, level, namespace_, name_='attachment')
    def hasContent_(self):
        if (
            self.content is not None or
            self.form is not None or
            self.attachment or
            super(FormMessage, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FormMessage'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.alertIntervalType is not None and 'alertIntervalType' not in already_processed:
            already_processed.append('alertIntervalType')
            showIndent(outfile, level)
            outfile.write('alertIntervalType = "%s",\n' % (self.alertIntervalType,))
        if self.alertType is not None and 'alertType' not in already_processed:
            already_processed.append('alertType')
            showIndent(outfile, level)
            outfile.write('alertType = "%s",\n' % (self.alertType,))
        if self.brandingKey is not None and 'brandingKey' not in already_processed:
            already_processed.append('brandingKey')
            showIndent(outfile, level)
            outfile.write('brandingKey = "%s",\n' % (self.brandingKey,))
        if self.positiveReference is not None and 'positiveReference' not in already_processed:
            already_processed.append('positiveReference')
            showIndent(outfile, level)
            outfile.write('positiveReference = "%s",\n' % (self.positiveReference,))
        if self.vibrate is not None and 'vibrate' not in already_processed:
            already_processed.append('vibrate')
            showIndent(outfile, level)
            outfile.write('vibrate = %s,\n' % (self.vibrate,))
        if self.member is not None and 'member' not in already_processed:
            already_processed.append('member')
            showIndent(outfile, level)
            outfile.write('member = "%s",\n' % (self.member,))
        if self.autoLock is not None and 'autoLock' not in already_processed:
            already_processed.append('autoLock')
            showIndent(outfile, level)
            outfile.write('autoLock = %s,\n' % (self.autoLock,))
        if self.negativeReference is not None and 'negativeReference' not in already_processed:
            already_processed.append('negativeReference')
            showIndent(outfile, level)
            outfile.write('negativeReference = "%s",\n' % (self.negativeReference,))
        super(FormMessage, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FormMessage, self).exportLiteralChildren(outfile, level, name_)
        if self.content is not None:
            showIndent(outfile, level)
            outfile.write('content=model_.contentType1(\n')
            self.content.exportLiteral(outfile, level, name_='content')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.form is not None:
            showIndent(outfile, level)
            outfile.write('form=model_.Form(\n')
            self.form.exportLiteral(outfile, level, name_='form')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('attachment=[\n')
        level += 1
        for attachment_ in self.attachment:
            showIndent(outfile, level)
            outfile.write('model_.Attachment(\n')
            attachment_.exportLiteral(outfile, level, name_='Attachment')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alertIntervalType', node)
        if value is not None and 'alertIntervalType' not in already_processed:
            already_processed.append('alertIntervalType')
            self.alertIntervalType = value
            self.validate_AlertIntervalType(self.alertIntervalType)  # validate type AlertIntervalType
        value = find_attr_value_('alertType', node)
        if value is not None and 'alertType' not in already_processed:
            already_processed.append('alertType')
            self.alertType = value
            self.validate_AlertType(self.alertType)  # validate type AlertType
        value = find_attr_value_('brandingKey', node)
        if value is not None and 'brandingKey' not in already_processed:
            already_processed.append('brandingKey')
            self.brandingKey = value
        value = find_attr_value_('positiveReference', node)
        if value is not None and 'positiveReference' not in already_processed:
            already_processed.append('positiveReference')
            self.positiveReference = value
        value = find_attr_value_('vibrate', node)
        if value is not None and 'vibrate' not in already_processed:
            already_processed.append('vibrate')
            if value in ('true', '1'):
                self.vibrate = True
            elif value in ('false', '0'):
                self.vibrate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('member', node)
        if value is not None and 'member' not in already_processed:
            already_processed.append('member')
            self.member = value
        value = find_attr_value_('autoLock', node)
        if value is not None and 'autoLock' not in already_processed:
            already_processed.append('autoLock')
            if value in ('true', '1'):
                self.autoLock = True
            elif value in ('false', '0'):
                self.autoLock = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('negativeReference', node)
        if value is not None and 'negativeReference' not in already_processed:
            already_processed.append('negativeReference')
            self.negativeReference = value
        super(FormMessage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = contentType1.factory()
            obj_.build(child_)
            self.set_content(obj_)
        elif nodeName_ == 'form':
            obj_ = Form.factory()
            obj_.build(child_)
            self.set_form(obj_)
        elif nodeName_ == 'attachment':
            obj_ = Attachment.factory()
            obj_.build(child_)
            self.attachment.append(obj_)
        super(FormMessage, self).buildChildren(child_, node, nodeName_, True)
# end class FormMessage


class Outlet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, reference=None, name=None, value=None):
        self.reference = _cast(None, reference)
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if Outlet.subclass:
            return Outlet.subclass(*args_, **kwargs_)
        else:
            return Outlet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='mstns:', name_='Outlet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Outlet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='Outlet'):
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            outfile.write(' reference=%s' % (self.gds_format_string(quote_attrib(self.reference).encode(ExternalEncoding), input_name='reference'),))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'),))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='Outlet', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Outlet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            showIndent(outfile, level)
            outfile.write('reference = "%s",\n' % (self.reference,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.append('reference')
            self.reference = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Outlet


class End(FlowElement):
    subclass = None
    superclass = FlowElement
    def __init__(self, id=None, waitForFollowUpMessage=False):
        super(End, self).__init__(id,)
        self.waitForFollowUpMessage = _cast(bool, waitForFollowUpMessage)
        pass
    def factory(*args_, **kwargs_):
        if End.subclass:
            return End.subclass(*args_, **kwargs_)
        else:
            return End(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_waitForFollowUpMessage(self): return self.waitForFollowUpMessage
    def set_waitForFollowUpMessage(self, waitForFollowUpMessage): self.waitForFollowUpMessage = waitForFollowUpMessage
    def export(self, outfile, level, namespace_='mstns:', name_='End', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='End')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='End'):
        super(End, self).exportAttributes(outfile, level, already_processed, namespace_, name_='End')
        if self.waitForFollowUpMessage is not None and 'waitForFollowUpMessage' not in already_processed:
            already_processed.append('waitForFollowUpMessage')
            outfile.write(' waitForFollowUpMessage="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.waitForFollowUpMessage)), input_name='waitForFollowUpMessage'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='End', fromsubclass_=False):
        super(End, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(End, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='End'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.waitForFollowUpMessage is not None and 'waitForFollowUpMessage' not in already_processed:
            already_processed.append('waitForFollowUpMessage')
            showIndent(outfile, level)
            outfile.write('waitForFollowUpMessage = %s,\n' % (self.waitForFollowUpMessage,))
        super(End, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(End, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('waitForFollowUpMessage', node)
        if value is not None and 'waitForFollowUpMessage' not in already_processed:
            already_processed.append('waitForFollowUpMessage')
            if value in ('true', '1'):
                self.waitForFollowUpMessage = True
            elif value in ('false', '0'):
                self.waitForFollowUpMessage = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(End, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(End, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class End


class MessageFlowDefinition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, language=None, startReference=None, end=None, message=None, formMessage=None, resultsFlush=None, resultsEmail=None, flowCode=None):
        self.name = _cast(None, name)
        self.language = _cast(None, language)
        self.startReference = _cast(None, startReference)
        if end is None:
            self.end = []
        else:
            self.end = end
        if message is None:
            self.message = []
        else:
            self.message = message
        if formMessage is None:
            self.formMessage = []
        else:
            self.formMessage = formMessage
        if resultsFlush is None:
            self.resultsFlush = []
        else:
            self.resultsFlush = resultsFlush
        if resultsEmail is None:
            self.resultsEmail = []
        else:
            self.resultsEmail = resultsEmail
        if flowCode is None:
            self.flowCode = []
        else:
            self.flowCode = flowCode
    def factory(*args_, **kwargs_):
        if MessageFlowDefinition.subclass:
            return MessageFlowDefinition.subclass(*args_, **kwargs_)
        else:
            return MessageFlowDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def add_end(self, value): self.end.append(value)
    def insert_end(self, index, value): self.end[index] = value
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def add_message(self, value): self.message.append(value)
    def insert_message(self, index, value): self.message[index] = value
    def get_formMessage(self): return self.formMessage
    def set_formMessage(self, formMessage): self.formMessage = formMessage
    def add_formMessage(self, value): self.formMessage.append(value)
    def insert_formMessage(self, index, value): self.formMessage[index] = value
    def get_resultsFlush(self): return self.resultsFlush
    def set_resultsFlush(self, resultsFlush): self.resultsFlush = resultsFlush
    def add_resultsFlush(self, value): self.resultsFlush.append(value)
    def insert_resultsFlush(self, index, value): self.resultsFlush[index] = value
    def get_resultsEmail(self): return self.resultsEmail
    def set_resultsEmail(self, resultsEmail): self.resultsEmail = resultsEmail
    def add_resultsEmail(self, value): self.resultsEmail.append(value)
    def insert_resultsEmail(self, index, value): self.resultsEmail[index] = value
    def get_flowCode(self): return self.flowCode
    def set_flowCode(self, flowCode): self.flowCode = flowCode
    def add_flowCode(self, value): self.flowCode.append(value)
    def insert_flowCode(self, index, value): self.flowCode[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_startReference(self): return self.startReference
    def set_startReference(self, startReference): self.startReference = startReference
    def export(self, outfile, level, namespace_='mstns:', name_='MessageFlowDefinition', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessageFlowDefinition')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='MessageFlowDefinition'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'),))
        if self.language is not None and 'language' not in already_processed:
            already_processed.append('language')
            outfile.write(' language=%s' % (self.gds_format_string(quote_attrib(self.language).encode(ExternalEncoding), input_name='language'),))
        if self.startReference is not None and 'startReference' not in already_processed:
            already_processed.append('startReference')
            outfile.write(' startReference=%s' % (self.gds_format_string(quote_attrib(self.startReference).encode(ExternalEncoding), input_name='startReference'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='MessageFlowDefinition', fromsubclass_=False):
        for end_ in self.end:
            end_.export(outfile, level, namespace_, name_='end')
        for message_ in self.message:
            message_.export(outfile, level, namespace_, name_='message')
        for formMessage_ in self.formMessage:
            formMessage_.export(outfile, level, namespace_, name_='formMessage')
        for resultsFlush_ in self.resultsFlush:
            resultsFlush_.export(outfile, level, namespace_, name_='resultsFlush')
        for resultsEmail_ in self.resultsEmail:
            resultsEmail_.export(outfile, level, namespace_, name_='resultsEmail')
        for flowCode_ in self.flowCode:
            flowCode_.export(outfile, level, namespace_, name_='flowCode')
    def hasContent_(self):
        if (
            self.end or
            self.message or
            self.formMessage or
            self.resultsFlush or
            self.resultsEmail or
            self.flowCode
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MessageFlowDefinition'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.language is not None and 'language' not in already_processed:
            already_processed.append('language')
            showIndent(outfile, level)
            outfile.write('language = "%s",\n' % (self.language,))
        if self.startReference is not None and 'startReference' not in already_processed:
            already_processed.append('startReference')
            showIndent(outfile, level)
            outfile.write('startReference = "%s",\n' % (self.startReference,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('end=[\n')
        level += 1
        for end_ in self.end:
            showIndent(outfile, level)
            outfile.write('model_.End(\n')
            end_.exportLiteral(outfile, level, name_='End')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('message=[\n')
        level += 1
        for message_ in self.message:
            showIndent(outfile, level)
            outfile.write('model_.Message(\n')
            message_.exportLiteral(outfile, level, name_='Message')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('formMessage=[\n')
        level += 1
        for formMessage_ in self.formMessage:
            showIndent(outfile, level)
            outfile.write('model_.FormMessage(\n')
            formMessage_.exportLiteral(outfile, level, name_='FormMessage')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resultsFlush=[\n')
        level += 1
        for resultsFlush_ in self.resultsFlush:
            showIndent(outfile, level)
            outfile.write('model_.ResultsFlush(\n')
            resultsFlush_.exportLiteral(outfile, level, name_='ResultsFlush')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resultsEmail=[\n')
        level += 1
        for resultsEmail_ in self.resultsEmail:
            showIndent(outfile, level)
            outfile.write('model_.ResultsEmail(\n')
            resultsEmail_.exportLiteral(outfile, level, name_='ResultsEmail')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('flowCode=[\n')
        level += 1
        for flowCode_ in self.flowCode:
            showIndent(outfile, level)
            outfile.write('model_.FlowCode(\n')
            flowCode_.exportLiteral(outfile, level, name_='FlowCode')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.append('language')
            self.language = value
        value = find_attr_value_('startReference', node)
        if value is not None and 'startReference' not in already_processed:
            already_processed.append('startReference')
            self.startReference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'end':
            obj_ = End.factory()
            obj_.build(child_)
            self.end.append(obj_)
        elif nodeName_ == 'message':
            obj_ = Message.factory()
            obj_.build(child_)
            self.message.append(obj_)
        elif nodeName_ == 'formMessage':
            obj_ = FormMessage.factory()
            obj_.build(child_)
            self.formMessage.append(obj_)
        elif nodeName_ == 'resultsFlush':
            obj_ = ResultsFlush.factory()
            obj_.build(child_)
            self.resultsFlush.append(obj_)
        elif nodeName_ == 'resultsEmail':
            obj_ = ResultsEmail.factory()
            obj_.build(child_)
            self.resultsEmail.append(obj_)
        elif nodeName_ == 'flowCode':
            obj_ = FlowCode.factory()
            obj_.build(child_)
            self.flowCode.append(obj_)
# end class MessageFlowDefinition


class MessageFlowDefinitionSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, definition=None):
        if definition is None:
            self.definition = []
        else:
            self.definition = definition
    def factory(*args_, **kwargs_):
        if MessageFlowDefinitionSet.subclass:
            return MessageFlowDefinitionSet.subclass(*args_, **kwargs_)
        else:
            return MessageFlowDefinitionSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definition(self): return self.definition
    def set_definition(self, definition): self.definition = definition
    def add_definition(self, value): self.definition.append(value)
    def insert_definition(self, index, value): self.definition[index] = value
    def export(self, outfile, level, namespace_='mstns:', name_='MessageFlowDefinitionSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessageFlowDefinitionSet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='MessageFlowDefinitionSet'):
        pass
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='MessageFlowDefinitionSet', fromsubclass_=False):
        for definition_ in self.definition:
            definition_.export(outfile, level, namespace_, name_='definition')
    def hasContent_(self):
        if (
            self.definition
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MessageFlowDefinitionSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('definition=[\n')
        level += 1
        for definition_ in self.definition:
            showIndent(outfile, level)
            outfile.write('model_.MessageFlowDefinition(\n')
            definition_.exportLiteral(outfile, level, name_='MessageFlowDefinition')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'definition':
            obj_ = MessageFlowDefinition.factory()
            obj_.build(child_)
            self.definition.append(obj_)
# end class MessageFlowDefinitionSet


class Step(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, extensiontype_=None):
        self.definition = _cast(None, definition)
        self.previousStep = _cast(None, previousStep)
        self.button = _cast(None, button)
        self.nextStep = _cast(None, nextStep)
        self.message = _cast(None, message)
        self.creationTimestamp = _cast(int, creationTimestamp)
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Step.subclass:
            return Step.subclass(*args_, **kwargs_)
        else:
            return Step(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definition(self): return self.definition
    def set_definition(self, definition): self.definition = definition
    def get_previousStep(self): return self.previousStep
    def set_previousStep(self, previousStep): self.previousStep = previousStep
    def get_button(self): return self.button
    def set_button(self, button): self.button = button
    def get_nextStep(self): return self.nextStep
    def set_nextStep(self, nextStep): self.nextStep = nextStep
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_creationTimestamp(self): return self.creationTimestamp
    def set_creationTimestamp(self, creationTimestamp): self.creationTimestamp = creationTimestamp
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='mstns:', name_='Step', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Step')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='Step'):
        if self.definition is not None and 'definition' not in already_processed:
            already_processed.append('definition')
            outfile.write(' definition=%s' % (self.gds_format_string(quote_attrib(self.definition).encode(ExternalEncoding), input_name='definition'),))
        if self.previousStep is not None and 'previousStep' not in already_processed:
            already_processed.append('previousStep')
            outfile.write(' previousStep=%s' % (self.gds_format_string(quote_attrib(self.previousStep).encode(ExternalEncoding), input_name='previousStep'),))
        if self.button is not None and 'button' not in already_processed:
            already_processed.append('button')
            outfile.write(' button=%s' % (self.gds_format_string(quote_attrib(self.button).encode(ExternalEncoding), input_name='button'),))
        if self.nextStep is not None and 'nextStep' not in already_processed:
            already_processed.append('nextStep')
            outfile.write(' nextStep=%s' % (self.gds_format_string(quote_attrib(self.nextStep).encode(ExternalEncoding), input_name='nextStep'),))
        if self.message is not None and 'message' not in already_processed:
            already_processed.append('message')
            outfile.write(' message=%s' % (self.gds_format_string(quote_attrib(self.message).encode(ExternalEncoding), input_name='message'),))
        if self.creationTimestamp is not None and 'creationTimestamp' not in already_processed:
            already_processed.append('creationTimestamp')
            outfile.write(' creationTimestamp="%s"' % self.gds_format_integer(self.creationTimestamp, input_name='creationTimestamp'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='Step', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Step'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.definition is not None and 'definition' not in already_processed:
            already_processed.append('definition')
            showIndent(outfile, level)
            outfile.write('definition = "%s",\n' % (self.definition,))
        if self.previousStep is not None and 'previousStep' not in already_processed:
            already_processed.append('previousStep')
            showIndent(outfile, level)
            outfile.write('previousStep = "%s",\n' % (self.previousStep,))
        if self.button is not None and 'button' not in already_processed:
            already_processed.append('button')
            showIndent(outfile, level)
            outfile.write('button = "%s",\n' % (self.button,))
        if self.nextStep is not None and 'nextStep' not in already_processed:
            already_processed.append('nextStep')
            showIndent(outfile, level)
            outfile.write('nextStep = "%s",\n' % (self.nextStep,))
        if self.message is not None and 'message' not in already_processed:
            already_processed.append('message')
            showIndent(outfile, level)
            outfile.write('message = "%s",\n' % (self.message,))
        if self.creationTimestamp is not None and 'creationTimestamp' not in already_processed:
            already_processed.append('creationTimestamp')
            showIndent(outfile, level)
            outfile.write('creationTimestamp = %d,\n' % (self.creationTimestamp,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('definition', node)
        if value is not None and 'definition' not in already_processed:
            already_processed.append('definition')
            self.definition = value
        value = find_attr_value_('previousStep', node)
        if value is not None and 'previousStep' not in already_processed:
            already_processed.append('previousStep')
            self.previousStep = value
        value = find_attr_value_('button', node)
        if value is not None and 'button' not in already_processed:
            already_processed.append('button')
            self.button = value
        value = find_attr_value_('nextStep', node)
        if value is not None and 'nextStep' not in already_processed:
            already_processed.append('nextStep')
            self.nextStep = value
        value = find_attr_value_('message', node)
        if value is not None and 'message' not in already_processed:
            already_processed.append('message')
            self.message = value
        value = find_attr_value_('creationTimestamp', node)
        if value is not None and 'creationTimestamp' not in already_processed:
            already_processed.append('creationTimestamp')
            try:
                self.creationTimestamp = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Step


class BaseMessageStep(Step):
    subclass = None
    superclass = Step
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, extensiontype_=None):
        super(BaseMessageStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, extensiontype_,)
        self.receivedTimestamp = _cast(int, receivedTimestamp)
        self.acknowledgedTimestamp = _cast(int, acknowledgedTimestamp)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if BaseMessageStep.subclass:
            return BaseMessageStep.subclass(*args_, **kwargs_)
        else:
            return BaseMessageStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_receivedTimestamp(self): return self.receivedTimestamp
    def set_receivedTimestamp(self, receivedTimestamp): self.receivedTimestamp = receivedTimestamp
    def get_acknowledgedTimestamp(self): return self.acknowledgedTimestamp
    def set_acknowledgedTimestamp(self, acknowledgedTimestamp): self.acknowledgedTimestamp = acknowledgedTimestamp
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='mstns:', name_='BaseMessageStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaseMessageStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='BaseMessageStep'):
        super(BaseMessageStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BaseMessageStep')
        if self.receivedTimestamp is not None and 'receivedTimestamp' not in already_processed:
            already_processed.append('receivedTimestamp')
            outfile.write(' receivedTimestamp="%s"' % self.gds_format_integer(self.receivedTimestamp, input_name='receivedTimestamp'))
        if self.acknowledgedTimestamp is not None and 'acknowledgedTimestamp' not in already_processed:
            already_processed.append('acknowledgedTimestamp')
            outfile.write(' acknowledgedTimestamp="%s"' % self.gds_format_integer(self.acknowledgedTimestamp, input_name='acknowledgedTimestamp'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='BaseMessageStep', fromsubclass_=False):
        super(BaseMessageStep, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(BaseMessageStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BaseMessageStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.receivedTimestamp is not None and 'receivedTimestamp' not in already_processed:
            already_processed.append('receivedTimestamp')
            showIndent(outfile, level)
            outfile.write('receivedTimestamp = %d,\n' % (self.receivedTimestamp,))
        if self.acknowledgedTimestamp is not None and 'acknowledgedTimestamp' not in already_processed:
            already_processed.append('acknowledgedTimestamp')
            showIndent(outfile, level)
            outfile.write('acknowledgedTimestamp = %d,\n' % (self.acknowledgedTimestamp,))
        super(BaseMessageStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BaseMessageStep, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('receivedTimestamp', node)
        if value is not None and 'receivedTimestamp' not in already_processed:
            already_processed.append('receivedTimestamp')
            try:
                self.receivedTimestamp = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('acknowledgedTimestamp', node)
        if value is not None and 'acknowledgedTimestamp' not in already_processed:
            already_processed.append('acknowledgedTimestamp')
            try:
                self.acknowledgedTimestamp = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(BaseMessageStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BaseMessageStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseMessageStep


class MessageStep(BaseMessageStep):
    subclass = None
    superclass = BaseMessageStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, answer=None):
        super(MessageStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp,)
        self.answer = _cast(None, answer)
        pass
    def factory(*args_, **kwargs_):
        if MessageStep.subclass:
            return MessageStep.subclass(*args_, **kwargs_)
        else:
            return MessageStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_answer(self): return self.answer
    def set_answer(self, answer): self.answer = answer
    def export(self, outfile, level, namespace_='mstns:', name_='MessageStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessageStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='MessageStep'):
        super(MessageStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MessageStep')
        if self.answer is not None and 'answer' not in already_processed:
            already_processed.append('answer')
            outfile.write(' answer=%s' % (self.gds_format_string(quote_attrib(self.answer).encode(ExternalEncoding), input_name='answer'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='MessageStep', fromsubclass_=False):
        super(MessageStep, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(MessageStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MessageStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.answer is not None and 'answer' not in already_processed:
            already_processed.append('answer')
            showIndent(outfile, level)
            outfile.write('answer = "%s",\n' % (self.answer,))
        super(MessageStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MessageStep, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('answer', node)
        if value is not None and 'answer' not in already_processed:
            already_processed.append('answer')
            self.answer = value
        super(MessageStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MessageStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MessageStep


class WidgetStep(BaseMessageStep):
    subclass = None
    superclass = BaseMessageStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, formButton=None, displayValue=None, extensiontype_=None):
        super(WidgetStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp, extensiontype_,)
        self.formButton = _cast(None, formButton)
        self.displayValue = _cast(None, displayValue)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if WidgetStep.subclass:
            return WidgetStep.subclass(*args_, **kwargs_)
        else:
            return WidgetStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_formButton(self): return self.formButton
    def set_formButton(self, formButton): self.formButton = formButton
    def validate_FormButton(self, value):
        # Validate type FormButton, a restriction on xs:string.
        pass
    def get_displayValue(self): return self.displayValue
    def set_displayValue(self, displayValue): self.displayValue = displayValue
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='mstns:', name_='WidgetStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WidgetStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='WidgetStep'):
        super(WidgetStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='WidgetStep')
        if self.formButton is not None and 'formButton' not in already_processed:
            already_processed.append('formButton')
            outfile.write(' formButton=%s' % (quote_attrib(self.formButton),))
        if self.displayValue is not None and 'displayValue' not in already_processed:
            already_processed.append('displayValue')
            outfile.write(' displayValue=%s' % (self.gds_format_string(quote_attrib(self.displayValue).encode(ExternalEncoding), input_name='displayValue'),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='WidgetStep', fromsubclass_=False):
        super(WidgetStep, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(WidgetStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WidgetStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.formButton is not None and 'formButton' not in already_processed:
            already_processed.append('formButton')
            showIndent(outfile, level)
            outfile.write('formButton = "%s",\n' % (self.formButton,))
        if self.displayValue is not None and 'displayValue' not in already_processed:
            already_processed.append('displayValue')
            showIndent(outfile, level)
            outfile.write('displayValue = "%s",\n' % (self.displayValue,))
        super(WidgetStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(WidgetStep, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('formButton', node)
        if value is not None and 'formButton' not in already_processed:
            already_processed.append('formButton')
            self.formButton = value
            self.validate_FormButton(self.formButton)  # validate type FormButton
        value = find_attr_value_('displayValue', node)
        if value is not None and 'displayValue' not in already_processed:
            already_processed.append('displayValue')
            self.displayValue = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(WidgetStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WidgetStep


class TextWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, formButton=None, displayValue=None, value=None):
        super(TextWidgetStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp, formButton, displayValue,)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if TextWidgetStep.subclass:
            return TextWidgetStep.subclass(*args_, **kwargs_)
        else:
            return TextWidgetStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='mstns:', name_='TextWidgetStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextWidgetStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='TextWidgetStep'):
        super(TextWidgetStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TextWidgetStep')
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='TextWidgetStep', fromsubclass_=False):
        super(TextWidgetStep, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(TextWidgetStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TextWidgetStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        super(TextWidgetStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TextWidgetStep, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        super(TextWidgetStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextWidgetStep


class SliderWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, formButton=None, displayValue=None, value=None):
        super(SliderWidgetStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp, formButton, displayValue,)
        self.value = _cast(float, value)
        pass
    def factory(*args_, **kwargs_):
        if SliderWidgetStep.subclass:
            return SliderWidgetStep.subclass(*args_, **kwargs_)
        else:
            return SliderWidgetStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='mstns:', name_='SliderWidgetStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SliderWidgetStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='SliderWidgetStep'):
        super(SliderWidgetStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SliderWidgetStep')
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value="%s"' % self.gds_format_float(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='SliderWidgetStep', fromsubclass_=False):
        super(SliderWidgetStep, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(SliderWidgetStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SliderWidgetStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %f,\n' % (self.value,))
        super(SliderWidgetStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SliderWidgetStep, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            try:
                self.value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        super(SliderWidgetStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SliderWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SliderWidgetStep


class RangeSliderWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, formButton=None, displayValue=None, value=None):
        super(RangeSliderWidgetStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp, formButton, displayValue,)
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if RangeSliderWidgetStep.subclass:
            return RangeSliderWidgetStep.subclass(*args_, **kwargs_)
        else:
            return RangeSliderWidgetStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def export(self, outfile, level, namespace_='mstns:', name_='RangeSliderWidgetStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RangeSliderWidgetStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='RangeSliderWidgetStep'):
        super(RangeSliderWidgetStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RangeSliderWidgetStep')
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='RangeSliderWidgetStep', fromsubclass_=False):
        super(RangeSliderWidgetStep, self).exportChildren(outfile, level, namespace_, name_, True)
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value')
    def hasContent_(self):
        if (
            self.value or
            super(RangeSliderWidgetStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RangeSliderWidgetStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RangeSliderWidgetStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RangeSliderWidgetStep, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.FloatValue(\n')
            value_.exportLiteral(outfile, level, name_='FloatValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(RangeSliderWidgetStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            obj_ = FloatValue.factory()
            obj_.build(child_)
            self.value.append(obj_)
        super(RangeSliderWidgetStep, self).buildChildren(child_, node, nodeName_, True)
# end class RangeSliderWidgetStep


class PhotoUploadWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, formButton=None, displayValue=None, value=None):
        super(PhotoUploadWidgetStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp, formButton, displayValue,)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if PhotoUploadWidgetStep.subclass:
            return PhotoUploadWidgetStep.subclass(*args_, **kwargs_)
        else:
            return PhotoUploadWidgetStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='mstns:', name_='PhotoUploadWidgetStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotoUploadWidgetStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='PhotoUploadWidgetStep'):
        super(PhotoUploadWidgetStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PhotoUploadWidgetStep')
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='PhotoUploadWidgetStep', fromsubclass_=False):
        super(PhotoUploadWidgetStep, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(PhotoUploadWidgetStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PhotoUploadWidgetStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        super(PhotoUploadWidgetStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PhotoUploadWidgetStep, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        super(PhotoUploadWidgetStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PhotoUploadWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PhotoUploadWidgetStep


class GPSLocationWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, formButton=None, displayValue=None, timestamp=None, altitude=None, longitude=None, horizontalAccuracy=None, latitude=None, verticalAccuracy=None):
        super(GPSLocationWidgetStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp, formButton, displayValue,)
        self.timestamp = _cast(int, timestamp)
        self.altitude = _cast(float, altitude)
        self.longitude = _cast(float, longitude)
        self.horizontalAccuracy = _cast(float, horizontalAccuracy)
        self.latitude = _cast(float, latitude)
        self.verticalAccuracy = _cast(float, verticalAccuracy)
        pass
    def factory(*args_, **kwargs_):
        if GPSLocationWidgetStep.subclass:
            return GPSLocationWidgetStep.subclass(*args_, **kwargs_)
        else:
            return GPSLocationWidgetStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_altitude(self): return self.altitude
    def set_altitude(self, altitude): self.altitude = altitude
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def get_horizontalAccuracy(self): return self.horizontalAccuracy
    def set_horizontalAccuracy(self, horizontalAccuracy): self.horizontalAccuracy = horizontalAccuracy
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def get_verticalAccuracy(self): return self.verticalAccuracy
    def set_verticalAccuracy(self, verticalAccuracy): self.verticalAccuracy = verticalAccuracy
    def export(self, outfile, level, namespace_='mstns:', name_='GPSLocationWidgetStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GPSLocationWidgetStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='GPSLocationWidgetStep'):
        super(GPSLocationWidgetStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GPSLocationWidgetStep')
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            outfile.write(' timestamp="%s"' % self.gds_format_integer(self.timestamp, input_name='timestamp'))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.append('altitude')
            outfile.write(' altitude="%s"' % self.gds_format_float(self.altitude, input_name='altitude'))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.append('longitude')
            outfile.write(' longitude="%s"' % self.gds_format_float(self.longitude, input_name='longitude'))
        if self.horizontalAccuracy is not None and 'horizontalAccuracy' not in already_processed:
            already_processed.append('horizontalAccuracy')
            outfile.write(' horizontalAccuracy="%s"' % self.gds_format_float(self.horizontalAccuracy, input_name='horizontalAccuracy'))
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.append('latitude')
            outfile.write(' latitude="%s"' % self.gds_format_float(self.latitude, input_name='latitude'))
        if self.verticalAccuracy is not None and 'verticalAccuracy' not in already_processed:
            already_processed.append('verticalAccuracy')
            outfile.write(' verticalAccuracy="%s"' % self.gds_format_float(self.verticalAccuracy, input_name='verticalAccuracy'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='GPSLocationWidgetStep', fromsubclass_=False):
        super(GPSLocationWidgetStep, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(GPSLocationWidgetStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GPSLocationWidgetStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            showIndent(outfile, level)
            outfile.write('timestamp = %d,\n' % (self.timestamp,))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.append('altitude')
            showIndent(outfile, level)
            outfile.write('altitude = %f,\n' % (self.altitude,))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.append('longitude')
            showIndent(outfile, level)
            outfile.write('longitude = %f,\n' % (self.longitude,))
        if self.horizontalAccuracy is not None and 'horizontalAccuracy' not in already_processed:
            already_processed.append('horizontalAccuracy')
            showIndent(outfile, level)
            outfile.write('horizontalAccuracy = %f,\n' % (self.horizontalAccuracy,))
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.append('latitude')
            showIndent(outfile, level)
            outfile.write('latitude = %f,\n' % (self.latitude,))
        if self.verticalAccuracy is not None and 'verticalAccuracy' not in already_processed:
            already_processed.append('verticalAccuracy')
            showIndent(outfile, level)
            outfile.write('verticalAccuracy = %f,\n' % (self.verticalAccuracy,))
        super(GPSLocationWidgetStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GPSLocationWidgetStep, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            try:
                self.timestamp = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.append('altitude')
            try:
                self.altitude = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (altitude): %s' % exp)
        value = find_attr_value_('longitude', node)
        if value is not None and 'longitude' not in already_processed:
            already_processed.append('longitude')
            try:
                self.longitude = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (longitude): %s' % exp)
        value = find_attr_value_('horizontalAccuracy', node)
        if value is not None and 'horizontalAccuracy' not in already_processed:
            already_processed.append('horizontalAccuracy')
            try:
                self.horizontalAccuracy = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (horizontalAccuracy): %s' % exp)
        value = find_attr_value_('latitude', node)
        if value is not None and 'latitude' not in already_processed:
            already_processed.append('latitude')
            try:
                self.latitude = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (latitude): %s' % exp)
        value = find_attr_value_('verticalAccuracy', node)
        if value is not None and 'verticalAccuracy' not in already_processed:
            already_processed.append('verticalAccuracy')
            try:
                self.verticalAccuracy = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (verticalAccuracy): %s' % exp)
        super(GPSLocationWidgetStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GPSLocationWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GPSLocationWidgetStep


class MyDigiPassEidProfile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, locationOfBirth=None, validityEndsAt=None, firstName=None, chipNumber=None, lastName=None, nobleCondition=None, validityBeginsAt=None, dateOfBirth=None, cardNumber=None, firstName3=None, gender=None, nationality=None, createdAt=None, issuingMunicipality=None):
        self.locationOfBirth = _cast(None, locationOfBirth)
        self.validityEndsAt = _cast(None, validityEndsAt)
        self.firstName = _cast(None, firstName)
        self.chipNumber = _cast(None, chipNumber)
        self.lastName = _cast(None, lastName)
        self.nobleCondition = _cast(None, nobleCondition)
        self.validityBeginsAt = _cast(None, validityBeginsAt)
        self.dateOfBirth = _cast(None, dateOfBirth)
        self.cardNumber = _cast(None, cardNumber)
        self.firstName3 = _cast(None, firstName3)
        self.gender = _cast(None, gender)
        self.nationality = _cast(None, nationality)
        self.createdAt = _cast(None, createdAt)
        self.issuingMunicipality = _cast(None, issuingMunicipality)
        pass
    def factory(*args_, **kwargs_):
        if MyDigiPassEidProfile.subclass:
            return MyDigiPassEidProfile.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassEidProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_locationOfBirth(self): return self.locationOfBirth
    def set_locationOfBirth(self, locationOfBirth): self.locationOfBirth = locationOfBirth
    def get_validityEndsAt(self): return self.validityEndsAt
    def set_validityEndsAt(self, validityEndsAt): self.validityEndsAt = validityEndsAt
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_chipNumber(self): return self.chipNumber
    def set_chipNumber(self, chipNumber): self.chipNumber = chipNumber
    def get_lastName(self): return self.lastName
    def set_lastName(self, lastName): self.lastName = lastName
    def get_nobleCondition(self): return self.nobleCondition
    def set_nobleCondition(self, nobleCondition): self.nobleCondition = nobleCondition
    def get_validityBeginsAt(self): return self.validityBeginsAt
    def set_validityBeginsAt(self, validityBeginsAt): self.validityBeginsAt = validityBeginsAt
    def get_dateOfBirth(self): return self.dateOfBirth
    def set_dateOfBirth(self, dateOfBirth): self.dateOfBirth = dateOfBirth
    def get_cardNumber(self): return self.cardNumber
    def set_cardNumber(self, cardNumber): self.cardNumber = cardNumber
    def get_firstName3(self): return self.firstName3
    def set_firstName3(self, firstName3): self.firstName3 = firstName3
    def get_gender(self): return self.gender
    def set_gender(self, gender): self.gender = gender
    def get_nationality(self): return self.nationality
    def set_nationality(self, nationality): self.nationality = nationality
    def get_createdAt(self): return self.createdAt
    def set_createdAt(self, createdAt): self.createdAt = createdAt
    def get_issuingMunicipality(self): return self.issuingMunicipality
    def set_issuingMunicipality(self, issuingMunicipality): self.issuingMunicipality = issuingMunicipality
    def export(self, outfile, level, namespace_='mstns:', name_='MyDigiPassEidProfile', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MyDigiPassEidProfile')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='MyDigiPassEidProfile'):
        if self.locationOfBirth is not None and 'locationOfBirth' not in already_processed:
            already_processed.append('locationOfBirth')
            outfile.write(' locationOfBirth=%s' % (self.gds_format_string(quote_attrib(self.locationOfBirth).encode(ExternalEncoding), input_name='locationOfBirth'),))
        if self.validityEndsAt is not None and 'validityEndsAt' not in already_processed:
            already_processed.append('validityEndsAt')
            outfile.write(' validityEndsAt=%s' % (self.gds_format_string(quote_attrib(self.validityEndsAt).encode(ExternalEncoding), input_name='validityEndsAt'),))
        if self.firstName is not None and 'firstName' not in already_processed:
            already_processed.append('firstName')
            outfile.write(' firstName=%s' % (self.gds_format_string(quote_attrib(self.firstName).encode(ExternalEncoding), input_name='firstName'),))
        if self.chipNumber is not None and 'chipNumber' not in already_processed:
            already_processed.append('chipNumber')
            outfile.write(' chipNumber=%s' % (self.gds_format_string(quote_attrib(self.chipNumber).encode(ExternalEncoding), input_name='chipNumber'),))
        if self.lastName is not None and 'lastName' not in already_processed:
            already_processed.append('lastName')
            outfile.write(' lastName=%s' % (self.gds_format_string(quote_attrib(self.lastName).encode(ExternalEncoding), input_name='lastName'),))
        if self.nobleCondition is not None and 'nobleCondition' not in already_processed:
            already_processed.append('nobleCondition')
            outfile.write(' nobleCondition=%s' % (self.gds_format_string(quote_attrib(self.nobleCondition).encode(ExternalEncoding), input_name='nobleCondition'),))
        if self.validityBeginsAt is not None and 'validityBeginsAt' not in already_processed:
            already_processed.append('validityBeginsAt')
            outfile.write(' validityBeginsAt=%s' % (self.gds_format_string(quote_attrib(self.validityBeginsAt).encode(ExternalEncoding), input_name='validityBeginsAt'),))
        if self.dateOfBirth is not None and 'dateOfBirth' not in already_processed:
            already_processed.append('dateOfBirth')
            outfile.write(' dateOfBirth=%s' % (self.gds_format_string(quote_attrib(self.dateOfBirth).encode(ExternalEncoding), input_name='dateOfBirth'),))
        if self.cardNumber is not None and 'cardNumber' not in already_processed:
            already_processed.append('cardNumber')
            outfile.write(' cardNumber=%s' % (self.gds_format_string(quote_attrib(self.cardNumber).encode(ExternalEncoding), input_name='cardNumber'),))
        if self.firstName3 is not None and 'firstName3' not in already_processed:
            already_processed.append('firstName3')
            outfile.write(' firstName3=%s' % (self.gds_format_string(quote_attrib(self.firstName3).encode(ExternalEncoding), input_name='firstName3'),))
        if self.gender is not None and 'gender' not in already_processed:
            already_processed.append('gender')
            outfile.write(' gender=%s' % (self.gds_format_string(quote_attrib(self.gender).encode(ExternalEncoding), input_name='gender'),))
        if self.nationality is not None and 'nationality' not in already_processed:
            already_processed.append('nationality')
            outfile.write(' nationality=%s' % (self.gds_format_string(quote_attrib(self.nationality).encode(ExternalEncoding), input_name='nationality'),))
        if self.createdAt is not None and 'createdAt' not in already_processed:
            already_processed.append('createdAt')
            outfile.write(' createdAt=%s' % (self.gds_format_string(quote_attrib(self.createdAt).encode(ExternalEncoding), input_name='createdAt'),))
        if self.issuingMunicipality is not None and 'issuingMunicipality' not in already_processed:
            already_processed.append('issuingMunicipality')
            outfile.write(' issuingMunicipality=%s' % (self.gds_format_string(quote_attrib(self.issuingMunicipality).encode(ExternalEncoding), input_name='issuingMunicipality'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='MyDigiPassEidProfile', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MyDigiPassEidProfile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.locationOfBirth is not None and 'locationOfBirth' not in already_processed:
            already_processed.append('locationOfBirth')
            showIndent(outfile, level)
            outfile.write('locationOfBirth = "%s",\n' % (self.locationOfBirth,))
        if self.validityEndsAt is not None and 'validityEndsAt' not in already_processed:
            already_processed.append('validityEndsAt')
            showIndent(outfile, level)
            outfile.write('validityEndsAt = "%s",\n' % (self.validityEndsAt,))
        if self.firstName is not None and 'firstName' not in already_processed:
            already_processed.append('firstName')
            showIndent(outfile, level)
            outfile.write('firstName = "%s",\n' % (self.firstName,))
        if self.chipNumber is not None and 'chipNumber' not in already_processed:
            already_processed.append('chipNumber')
            showIndent(outfile, level)
            outfile.write('chipNumber = "%s",\n' % (self.chipNumber,))
        if self.lastName is not None and 'lastName' not in already_processed:
            already_processed.append('lastName')
            showIndent(outfile, level)
            outfile.write('lastName = "%s",\n' % (self.lastName,))
        if self.nobleCondition is not None and 'nobleCondition' not in already_processed:
            already_processed.append('nobleCondition')
            showIndent(outfile, level)
            outfile.write('nobleCondition = "%s",\n' % (self.nobleCondition,))
        if self.validityBeginsAt is not None and 'validityBeginsAt' not in already_processed:
            already_processed.append('validityBeginsAt')
            showIndent(outfile, level)
            outfile.write('validityBeginsAt = "%s",\n' % (self.validityBeginsAt,))
        if self.dateOfBirth is not None and 'dateOfBirth' not in already_processed:
            already_processed.append('dateOfBirth')
            showIndent(outfile, level)
            outfile.write('dateOfBirth = "%s",\n' % (self.dateOfBirth,))
        if self.cardNumber is not None and 'cardNumber' not in already_processed:
            already_processed.append('cardNumber')
            showIndent(outfile, level)
            outfile.write('cardNumber = "%s",\n' % (self.cardNumber,))
        if self.firstName3 is not None and 'firstName3' not in already_processed:
            already_processed.append('firstName3')
            showIndent(outfile, level)
            outfile.write('firstName3 = "%s",\n' % (self.firstName3,))
        if self.gender is not None and 'gender' not in already_processed:
            already_processed.append('gender')
            showIndent(outfile, level)
            outfile.write('gender = "%s",\n' % (self.gender,))
        if self.nationality is not None and 'nationality' not in already_processed:
            already_processed.append('nationality')
            showIndent(outfile, level)
            outfile.write('nationality = "%s",\n' % (self.nationality,))
        if self.createdAt is not None and 'createdAt' not in already_processed:
            already_processed.append('createdAt')
            showIndent(outfile, level)
            outfile.write('createdAt = "%s",\n' % (self.createdAt,))
        if self.issuingMunicipality is not None and 'issuingMunicipality' not in already_processed:
            already_processed.append('issuingMunicipality')
            showIndent(outfile, level)
            outfile.write('issuingMunicipality = "%s",\n' % (self.issuingMunicipality,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locationOfBirth', node)
        if value is not None and 'locationOfBirth' not in already_processed:
            already_processed.append('locationOfBirth')
            self.locationOfBirth = value
        value = find_attr_value_('validityEndsAt', node)
        if value is not None and 'validityEndsAt' not in already_processed:
            already_processed.append('validityEndsAt')
            self.validityEndsAt = value
        value = find_attr_value_('firstName', node)
        if value is not None and 'firstName' not in already_processed:
            already_processed.append('firstName')
            self.firstName = value
        value = find_attr_value_('chipNumber', node)
        if value is not None and 'chipNumber' not in already_processed:
            already_processed.append('chipNumber')
            self.chipNumber = value
        value = find_attr_value_('lastName', node)
        if value is not None and 'lastName' not in already_processed:
            already_processed.append('lastName')
            self.lastName = value
        value = find_attr_value_('nobleCondition', node)
        if value is not None and 'nobleCondition' not in already_processed:
            already_processed.append('nobleCondition')
            self.nobleCondition = value
        value = find_attr_value_('validityBeginsAt', node)
        if value is not None and 'validityBeginsAt' not in already_processed:
            already_processed.append('validityBeginsAt')
            self.validityBeginsAt = value
        value = find_attr_value_('dateOfBirth', node)
        if value is not None and 'dateOfBirth' not in already_processed:
            already_processed.append('dateOfBirth')
            self.dateOfBirth = value
        value = find_attr_value_('cardNumber', node)
        if value is not None and 'cardNumber' not in already_processed:
            already_processed.append('cardNumber')
            self.cardNumber = value
        value = find_attr_value_('firstName3', node)
        if value is not None and 'firstName3' not in already_processed:
            already_processed.append('firstName3')
            self.firstName3 = value
        value = find_attr_value_('gender', node)
        if value is not None and 'gender' not in already_processed:
            already_processed.append('gender')
            self.gender = value
        value = find_attr_value_('nationality', node)
        if value is not None and 'nationality' not in already_processed:
            already_processed.append('nationality')
            self.nationality = value
        value = find_attr_value_('createdAt', node)
        if value is not None and 'createdAt' not in already_processed:
            already_processed.append('createdAt')
            self.createdAt = value
        value = find_attr_value_('issuingMunicipality', node)
        if value is not None and 'issuingMunicipality' not in already_processed:
            already_processed.append('issuingMunicipality')
            self.issuingMunicipality = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MyDigiPassEidProfile


class MyDigiPassEidAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, municipality=None, streetAndNumber=None, zipCode=None):
        self.municipality = _cast(None, municipality)
        self.streetAndNumber = _cast(None, streetAndNumber)
        self.zipCode = _cast(None, zipCode)
        pass
    def factory(*args_, **kwargs_):
        if MyDigiPassEidAddress.subclass:
            return MyDigiPassEidAddress.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassEidAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_municipality(self): return self.municipality
    def set_municipality(self, municipality): self.municipality = municipality
    def get_streetAndNumber(self): return self.streetAndNumber
    def set_streetAndNumber(self, streetAndNumber): self.streetAndNumber = streetAndNumber
    def get_zipCode(self): return self.zipCode
    def set_zipCode(self, zipCode): self.zipCode = zipCode
    def export(self, outfile, level, namespace_='mstns:', name_='MyDigiPassEidAddress', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MyDigiPassEidAddress')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='MyDigiPassEidAddress'):
        if self.municipality is not None and 'municipality' not in already_processed:
            already_processed.append('municipality')
            outfile.write(' municipality=%s' % (self.gds_format_string(quote_attrib(self.municipality).encode(ExternalEncoding), input_name='municipality'),))
        if self.streetAndNumber is not None and 'streetAndNumber' not in already_processed:
            already_processed.append('streetAndNumber')
            outfile.write(' streetAndNumber=%s' % (self.gds_format_string(quote_attrib(self.streetAndNumber).encode(ExternalEncoding), input_name='streetAndNumber'),))
        if self.zipCode is not None and 'zipCode' not in already_processed:
            already_processed.append('zipCode')
            outfile.write(' zipCode=%s' % (self.gds_format_string(quote_attrib(self.zipCode).encode(ExternalEncoding), input_name='zipCode'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='MyDigiPassEidAddress', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MyDigiPassEidAddress'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.municipality is not None and 'municipality' not in already_processed:
            already_processed.append('municipality')
            showIndent(outfile, level)
            outfile.write('municipality = "%s",\n' % (self.municipality,))
        if self.streetAndNumber is not None and 'streetAndNumber' not in already_processed:
            already_processed.append('streetAndNumber')
            showIndent(outfile, level)
            outfile.write('streetAndNumber = "%s",\n' % (self.streetAndNumber,))
        if self.zipCode is not None and 'zipCode' not in already_processed:
            already_processed.append('zipCode')
            showIndent(outfile, level)
            outfile.write('zipCode = "%s",\n' % (self.zipCode,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('municipality', node)
        if value is not None and 'municipality' not in already_processed:
            already_processed.append('municipality')
            self.municipality = value
        value = find_attr_value_('streetAndNumber', node)
        if value is not None and 'streetAndNumber' not in already_processed:
            already_processed.append('streetAndNumber')
            self.streetAndNumber = value
        value = find_attr_value_('zipCode', node)
        if value is not None and 'zipCode' not in already_processed:
            already_processed.append('zipCode')
            self.zipCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MyDigiPassEidAddress


class MyDigiPassProfile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uuid=None, firstName=None, lastName=None, preferredLocale=None, updatedAt=None, bornOn=None):
        self.uuid = _cast(None, uuid)
        self.firstName = _cast(None, firstName)
        self.lastName = _cast(None, lastName)
        self.preferredLocale = _cast(None, preferredLocale)
        self.updatedAt = _cast(None, updatedAt)
        self.bornOn = _cast(None, bornOn)
        pass
    def factory(*args_, **kwargs_):
        if MyDigiPassProfile.subclass:
            return MyDigiPassProfile.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_lastName(self): return self.lastName
    def set_lastName(self, lastName): self.lastName = lastName
    def get_preferredLocale(self): return self.preferredLocale
    def set_preferredLocale(self, preferredLocale): self.preferredLocale = preferredLocale
    def get_updatedAt(self): return self.updatedAt
    def set_updatedAt(self, updatedAt): self.updatedAt = updatedAt
    def get_bornOn(self): return self.bornOn
    def set_bornOn(self, bornOn): self.bornOn = bornOn
    def export(self, outfile, level, namespace_='mstns:', name_='MyDigiPassProfile', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MyDigiPassProfile')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='MyDigiPassProfile'):
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.append('uuid')
            outfile.write(' uuid=%s' % (self.gds_format_string(quote_attrib(self.uuid).encode(ExternalEncoding), input_name='uuid'),))
        if self.firstName is not None and 'firstName' not in already_processed:
            already_processed.append('firstName')
            outfile.write(' firstName=%s' % (self.gds_format_string(quote_attrib(self.firstName).encode(ExternalEncoding), input_name='firstName'),))
        if self.lastName is not None and 'lastName' not in already_processed:
            already_processed.append('lastName')
            outfile.write(' lastName=%s' % (self.gds_format_string(quote_attrib(self.lastName).encode(ExternalEncoding), input_name='lastName'),))
        if self.preferredLocale is not None and 'preferredLocale' not in already_processed:
            already_processed.append('preferredLocale')
            outfile.write(' preferredLocale=%s' % (self.gds_format_string(quote_attrib(self.preferredLocale).encode(ExternalEncoding), input_name='preferredLocale'),))
        if self.updatedAt is not None and 'updatedAt' not in already_processed:
            already_processed.append('updatedAt')
            outfile.write(' updatedAt=%s' % (self.gds_format_string(quote_attrib(self.updatedAt).encode(ExternalEncoding), input_name='updatedAt'),))
        if self.bornOn is not None and 'bornOn' not in already_processed:
            already_processed.append('bornOn')
            outfile.write(' bornOn=%s' % (self.gds_format_string(quote_attrib(self.bornOn).encode(ExternalEncoding), input_name='bornOn'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='MyDigiPassProfile', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MyDigiPassProfile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.append('uuid')
            showIndent(outfile, level)
            outfile.write('uuid = "%s",\n' % (self.uuid,))
        if self.firstName is not None and 'firstName' not in already_processed:
            already_processed.append('firstName')
            showIndent(outfile, level)
            outfile.write('firstName = "%s",\n' % (self.firstName,))
        if self.lastName is not None and 'lastName' not in already_processed:
            already_processed.append('lastName')
            showIndent(outfile, level)
            outfile.write('lastName = "%s",\n' % (self.lastName,))
        if self.preferredLocale is not None and 'preferredLocale' not in already_processed:
            already_processed.append('preferredLocale')
            showIndent(outfile, level)
            outfile.write('preferredLocale = "%s",\n' % (self.preferredLocale,))
        if self.updatedAt is not None and 'updatedAt' not in already_processed:
            already_processed.append('updatedAt')
            showIndent(outfile, level)
            outfile.write('updatedAt = "%s",\n' % (self.updatedAt,))
        if self.bornOn is not None and 'bornOn' not in already_processed:
            already_processed.append('bornOn')
            showIndent(outfile, level)
            outfile.write('bornOn = "%s",\n' % (self.bornOn,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uuid', node)
        if value is not None and 'uuid' not in already_processed:
            already_processed.append('uuid')
            self.uuid = value
        value = find_attr_value_('firstName', node)
        if value is not None and 'firstName' not in already_processed:
            already_processed.append('firstName')
            self.firstName = value
        value = find_attr_value_('lastName', node)
        if value is not None and 'lastName' not in already_processed:
            already_processed.append('lastName')
            self.lastName = value
        value = find_attr_value_('preferredLocale', node)
        if value is not None and 'preferredLocale' not in already_processed:
            already_processed.append('preferredLocale')
            self.preferredLocale = value
        value = find_attr_value_('updatedAt', node)
        if value is not None and 'updatedAt' not in already_processed:
            already_processed.append('updatedAt')
            self.updatedAt = value
        value = find_attr_value_('bornOn', node)
        if value is not None and 'bornOn' not in already_processed:
            already_processed.append('bornOn')
            self.bornOn = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MyDigiPassProfile


class MyDigiPassAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, city=None, zip=None, address1=None, address2=None, state=None, country=None):
        self.city = _cast(None, city)
        self.zip = _cast(None, zip)
        self.address1 = _cast(None, address1)
        self.address2 = _cast(None, address2)
        self.state = _cast(None, state)
        self.country = _cast(None, country)
        pass
    def factory(*args_, **kwargs_):
        if MyDigiPassAddress.subclass:
            return MyDigiPassAddress.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_zip(self): return self.zip
    def set_zip(self, zip): self.zip = zip
    def get_address1(self): return self.address1
    def set_address1(self, address1): self.address1 = address1
    def get_address2(self): return self.address2
    def set_address2(self, address2): self.address2 = address2
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def export(self, outfile, level, namespace_='mstns:', name_='MyDigiPassAddress', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MyDigiPassAddress')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='MyDigiPassAddress'):
        if self.city is not None and 'city' not in already_processed:
            already_processed.append('city')
            outfile.write(' city=%s' % (self.gds_format_string(quote_attrib(self.city).encode(ExternalEncoding), input_name='city'),))
        if self.zip is not None and 'zip' not in already_processed:
            already_processed.append('zip')
            outfile.write(' zip=%s' % (self.gds_format_string(quote_attrib(self.zip).encode(ExternalEncoding), input_name='zip'),))
        if self.address1 is not None and 'address1' not in already_processed:
            already_processed.append('address1')
            outfile.write(' address1=%s' % (self.gds_format_string(quote_attrib(self.address1).encode(ExternalEncoding), input_name='address1'),))
        if self.address2 is not None and 'address2' not in already_processed:
            already_processed.append('address2')
            outfile.write(' address2=%s' % (self.gds_format_string(quote_attrib(self.address2).encode(ExternalEncoding), input_name='address2'),))
        if self.state is not None and 'state' not in already_processed:
            already_processed.append('state')
            outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'),))
        if self.country is not None and 'country' not in already_processed:
            already_processed.append('country')
            outfile.write(' country=%s' % (self.gds_format_string(quote_attrib(self.country).encode(ExternalEncoding), input_name='country'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='MyDigiPassAddress', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MyDigiPassAddress'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.city is not None and 'city' not in already_processed:
            already_processed.append('city')
            showIndent(outfile, level)
            outfile.write('city = "%s",\n' % (self.city,))
        if self.zip is not None and 'zip' not in already_processed:
            already_processed.append('zip')
            showIndent(outfile, level)
            outfile.write('zip = "%s",\n' % (self.zip,))
        if self.address1 is not None and 'address1' not in already_processed:
            already_processed.append('address1')
            showIndent(outfile, level)
            outfile.write('address1 = "%s",\n' % (self.address1,))
        if self.address2 is not None and 'address2' not in already_processed:
            already_processed.append('address2')
            showIndent(outfile, level)
            outfile.write('address2 = "%s",\n' % (self.address2,))
        if self.state is not None and 'state' not in already_processed:
            already_processed.append('state')
            showIndent(outfile, level)
            outfile.write('state = "%s",\n' % (self.state,))
        if self.country is not None and 'country' not in already_processed:
            already_processed.append('country')
            showIndent(outfile, level)
            outfile.write('country = "%s",\n' % (self.country,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('city', node)
        if value is not None and 'city' not in already_processed:
            already_processed.append('city')
            self.city = value
        value = find_attr_value_('zip', node)
        if value is not None and 'zip' not in already_processed:
            already_processed.append('zip')
            self.zip = value
        value = find_attr_value_('address1', node)
        if value is not None and 'address1' not in already_processed:
            already_processed.append('address1')
            self.address1 = value
        value = find_attr_value_('address2', node)
        if value is not None and 'address2' not in already_processed:
            already_processed.append('address2')
            self.address2 = value
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.append('state')
            self.state = value
        value = find_attr_value_('country', node)
        if value is not None and 'country' not in already_processed:
            already_processed.append('country')
            self.country = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MyDigiPassAddress


class MyDigiPassWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, formButton=None, displayValue=None, phone=None, email=None, eidPhoto=None, eidProfile=None, eidAddress=None, profile=None, address=None):
        super(MyDigiPassWidgetStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp, formButton, displayValue,)
        self.phone = _cast(None, phone)
        self.email = _cast(None, email)
        self.eidPhoto = _cast(None, eidPhoto)
        self.eidProfile = eidProfile
        self.eidAddress = eidAddress
        self.profile = profile
        self.address = address
    def factory(*args_, **kwargs_):
        if MyDigiPassWidgetStep.subclass:
            return MyDigiPassWidgetStep.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassWidgetStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eidProfile(self): return self.eidProfile
    def set_eidProfile(self, eidProfile): self.eidProfile = eidProfile
    def get_eidAddress(self): return self.eidAddress
    def set_eidAddress(self, eidAddress): self.eidAddress = eidAddress
    def get_profile(self): return self.profile
    def set_profile(self, profile): self.profile = profile
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_phone(self): return self.phone
    def set_phone(self, phone): self.phone = phone
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def get_eidPhoto(self): return self.eidPhoto
    def set_eidPhoto(self, eidPhoto): self.eidPhoto = eidPhoto
    def export(self, outfile, level, namespace_='mstns:', name_='MyDigiPassWidgetStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MyDigiPassWidgetStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='MyDigiPassWidgetStep'):
        super(MyDigiPassWidgetStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MyDigiPassWidgetStep')
        if self.phone is not None and 'phone' not in already_processed:
            already_processed.append('phone')
            outfile.write(' phone=%s' % (self.gds_format_string(quote_attrib(self.phone).encode(ExternalEncoding), input_name='phone'),))
        if self.email is not None and 'email' not in already_processed:
            already_processed.append('email')
            outfile.write(' email=%s' % (self.gds_format_string(quote_attrib(self.email).encode(ExternalEncoding), input_name='email'),))
        if self.eidPhoto is not None and 'eidPhoto' not in already_processed:
            already_processed.append('eidPhoto')
            outfile.write(' eidPhoto=%s' % (self.gds_format_string(quote_attrib(self.eidPhoto).encode(ExternalEncoding), input_name='eidPhoto'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='MyDigiPassWidgetStep', fromsubclass_=False):
        super(MyDigiPassWidgetStep, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.eidProfile is not None:
            self.eidProfile.export(outfile, level, namespace_, name_='eidProfile')
        if self.eidAddress is not None:
            self.eidAddress.export(outfile, level, namespace_, name_='eidAddress')
        if self.profile is not None:
            self.profile.export(outfile, level, namespace_, name_='profile')
        if self.address is not None:
            self.address.export(outfile, level, namespace_, name_='address')
    def hasContent_(self):
        if (
            self.eidProfile is not None or
            self.eidAddress is not None or
            self.profile is not None or
            self.address is not None or
            super(MyDigiPassWidgetStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MyDigiPassWidgetStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.phone is not None and 'phone' not in already_processed:
            already_processed.append('phone')
            showIndent(outfile, level)
            outfile.write('phone = "%s",\n' % (self.phone,))
        if self.email is not None and 'email' not in already_processed:
            already_processed.append('email')
            showIndent(outfile, level)
            outfile.write('email = "%s",\n' % (self.email,))
        if self.eidPhoto is not None and 'eidPhoto' not in already_processed:
            already_processed.append('eidPhoto')
            showIndent(outfile, level)
            outfile.write('eidPhoto = "%s",\n' % (self.eidPhoto,))
        super(MyDigiPassWidgetStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MyDigiPassWidgetStep, self).exportLiteralChildren(outfile, level, name_)
        if self.eidProfile is not None:
            showIndent(outfile, level)
            outfile.write('eidProfile=model_.MyDigiPassEidProfile(\n')
            self.eidProfile.exportLiteral(outfile, level, name_='eidProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.eidAddress is not None:
            showIndent(outfile, level)
            outfile.write('eidAddress=model_.MyDigiPassEidAddress(\n')
            self.eidAddress.exportLiteral(outfile, level, name_='eidAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.profile is not None:
            showIndent(outfile, level)
            outfile.write('profile=model_.MyDigiPassProfile(\n')
            self.profile.exportLiteral(outfile, level, name_='profile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=model_.MyDigiPassAddress(\n')
            self.address.exportLiteral(outfile, level, name_='address')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('phone', node)
        if value is not None and 'phone' not in already_processed:
            already_processed.append('phone')
            self.phone = value
        value = find_attr_value_('email', node)
        if value is not None and 'email' not in already_processed:
            already_processed.append('email')
            self.email = value
        value = find_attr_value_('eidPhoto', node)
        if value is not None and 'eidPhoto' not in already_processed:
            already_processed.append('eidPhoto')
            self.eidPhoto = value
        super(MyDigiPassWidgetStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eidProfile':
            obj_ = MyDigiPassEidProfile.factory()
            obj_.build(child_)
            self.set_eidProfile(obj_)
        elif nodeName_ == 'eidAddress':
            obj_ = MyDigiPassEidAddress.factory()
            obj_.build(child_)
            self.set_eidAddress(obj_)
        elif nodeName_ == 'profile':
            obj_ = MyDigiPassProfile.factory()
            obj_.build(child_)
            self.set_profile(obj_)
        elif nodeName_ == 'address':
            obj_ = MyDigiPassAddress.factory()
            obj_.build(child_)
            self.set_address(obj_)
        super(MyDigiPassWidgetStep, self).buildChildren(child_, node, nodeName_, True)
# end class MyDigiPassWidgetStep


class SelectSingleWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, formButton=None, displayValue=None, value=None):
        super(SelectSingleWidgetStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp, formButton, displayValue,)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if SelectSingleWidgetStep.subclass:
            return SelectSingleWidgetStep.subclass(*args_, **kwargs_)
        else:
            return SelectSingleWidgetStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='mstns:', name_='SelectSingleWidgetStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SelectSingleWidgetStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='SelectSingleWidgetStep'):
        super(SelectSingleWidgetStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SelectSingleWidgetStep')
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='SelectSingleWidgetStep', fromsubclass_=False):
        super(SelectSingleWidgetStep, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(SelectSingleWidgetStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SelectSingleWidgetStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        super(SelectSingleWidgetStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SelectSingleWidgetStep, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        super(SelectSingleWidgetStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SelectSingleWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SelectSingleWidgetStep


class SelectMultiWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, formButton=None, displayValue=None, selection=None):
        super(SelectMultiWidgetStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp, formButton, displayValue,)
        if selection is None:
            self.selection = []
        else:
            self.selection = selection
    def factory(*args_, **kwargs_):
        if SelectMultiWidgetStep.subclass:
            return SelectMultiWidgetStep.subclass(*args_, **kwargs_)
        else:
            return SelectMultiWidgetStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_selection(self): return self.selection
    def set_selection(self, selection): self.selection = selection
    def add_selection(self, value): self.selection.append(value)
    def insert_selection(self, index, value): self.selection[index] = value
    def export(self, outfile, level, namespace_='mstns:', name_='SelectMultiWidgetStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SelectMultiWidgetStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='SelectMultiWidgetStep'):
        super(SelectMultiWidgetStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SelectMultiWidgetStep')
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='SelectMultiWidgetStep', fromsubclass_=False):
        super(SelectMultiWidgetStep, self).exportChildren(outfile, level, namespace_, name_, True)
        for selection_ in self.selection:
            selection_.export(outfile, level, namespace_, name_='selection')
    def hasContent_(self):
        if (
            self.selection or
            super(SelectMultiWidgetStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SelectMultiWidgetStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SelectMultiWidgetStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SelectMultiWidgetStep, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('selection=[\n')
        level += 1
        for selection_ in self.selection:
            showIndent(outfile, level)
            outfile.write('model_.Value(\n')
            selection_.exportLiteral(outfile, level, name_='Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SelectMultiWidgetStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'selection':
            class_obj_ = self.get_class_obj_(child_, Value)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.selection.append(obj_)
        super(SelectMultiWidgetStep, self).buildChildren(child_, node, nodeName_, True)
# end class SelectMultiWidgetStep


class SelectDateWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, formButton=None, displayValue=None, date=None):
        super(SelectDateWidgetStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp, formButton, displayValue,)
        self.date = _cast(int, date)
        pass
    def factory(*args_, **kwargs_):
        if SelectDateWidgetStep.subclass:
            return SelectDateWidgetStep.subclass(*args_, **kwargs_)
        else:
            return SelectDateWidgetStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def export(self, outfile, level, namespace_='mstns:', name_='SelectDateWidgetStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SelectDateWidgetStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='SelectDateWidgetStep'):
        super(SelectDateWidgetStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SelectDateWidgetStep')
        if self.date is not None and 'date' not in already_processed:
            already_processed.append('date')
            outfile.write(' date="%s"' % self.gds_format_integer(self.date, input_name='date'))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='SelectDateWidgetStep', fromsubclass_=False):
        super(SelectDateWidgetStep, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(SelectDateWidgetStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SelectDateWidgetStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.date is not None and 'date' not in already_processed:
            already_processed.append('date')
            showIndent(outfile, level)
            outfile.write('date = %d,\n' % (self.date,))
        super(SelectDateWidgetStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SelectDateWidgetStep, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.append('date')
            try:
                self.date = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(SelectDateWidgetStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SelectDateWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SelectDateWidgetStep


class AdvancedOrderWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep
    def __init__(self, definition=None, previousStep=None, button=None, nextStep=None, message=None, creationTimestamp=None, id=None, receivedTimestamp=None, acknowledgedTimestamp=None, formButton=None, displayValue=None, currency=None, category=None):
        super(AdvancedOrderWidgetStep, self).__init__(definition, previousStep, button, nextStep, message, creationTimestamp, id, receivedTimestamp, acknowledgedTimestamp, formButton, displayValue,)
        self.currency = _cast(None, currency)
        if category is None:
            self.category = []
        else:
            self.category = category
    def factory(*args_, **kwargs_):
        if AdvancedOrderWidgetStep.subclass:
            return AdvancedOrderWidgetStep.subclass(*args_, **kwargs_)
        else:
            return AdvancedOrderWidgetStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category(self, index, value): self.category[index] = value
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def export(self, outfile, level, namespace_='mstns:', name_='AdvancedOrderWidgetStep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdvancedOrderWidgetStep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='AdvancedOrderWidgetStep'):
        super(AdvancedOrderWidgetStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AdvancedOrderWidgetStep')
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            outfile.write(' currency=%s' % (self.gds_format_string(quote_attrib(self.currency).encode(ExternalEncoding), input_name='currency'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='AdvancedOrderWidgetStep', fromsubclass_=False):
        super(AdvancedOrderWidgetStep, self).exportChildren(outfile, level, namespace_, name_, True)
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category')
    def hasContent_(self):
        if (
            self.category or
            super(AdvancedOrderWidgetStep, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AdvancedOrderWidgetStep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            showIndent(outfile, level)
            outfile.write('currency = "%s",\n' % (self.currency,))
        super(AdvancedOrderWidgetStep, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AdvancedOrderWidgetStep, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('category=[\n')
        level += 1
        for category_ in self.category:
            showIndent(outfile, level)
            outfile.write('model_.AdvancedOrderCategory(\n')
            category_.exportLiteral(outfile, level, name_='AdvancedOrderCategory')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            self.currency = value
        super(AdvancedOrderWidgetStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'category':
            obj_ = AdvancedOrderCategory.factory()
            obj_.build(child_)
            self.category.append(obj_)
        super(AdvancedOrderWidgetStep, self).buildChildren(child_, node, nodeName_, True)
# end class AdvancedOrderWidgetStep


class MemberRun(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, status=None, userData=None, endReference=None, name=None, language=None, avatarUrl=None, appId=None, email=None, step=None):
        self.status = _cast(None, status)
        self.userData = _cast(None, userData)
        self.endReference = _cast(None, endReference)
        self.name = _cast(None, name)
        self.language = _cast(None, language)
        self.avatarUrl = _cast(None, avatarUrl)
        self.appId = _cast(None, appId)
        self.email = _cast(None, email)
        if step is None:
            self.step = []
        else:
            self.step = step
    def factory(*args_, **kwargs_):
        if MemberRun.subclass:
            return MemberRun.subclass(*args_, **kwargs_)
        else:
            return MemberRun(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def add_step(self, value): self.step.append(value)
    def insert_step(self, index, value): self.step[index] = value
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def validate_MemberStatus(self, value):
        # Validate type MemberStatus, a restriction on xs:string.
        pass
    def get_userData(self): return self.userData
    def set_userData(self, userData): self.userData = userData
    def get_endReference(self): return self.endReference
    def set_endReference(self, endReference): self.endReference = endReference
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_avatarUrl(self): return self.avatarUrl
    def set_avatarUrl(self, avatarUrl): self.avatarUrl = avatarUrl
    def get_appId(self): return self.appId
    def set_appId(self, appId): self.appId = appId
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def export(self, outfile, level, namespace_='mstns:', name_='MemberRun', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MemberRun')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='MemberRun'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status),))
        if self.userData is not None and 'userData' not in already_processed:
            already_processed.append('userData')
            outfile.write(' userData=%s' % (self.gds_format_string(quote_attrib(self.userData).encode(ExternalEncoding), input_name='userData'),))
        if self.endReference is not None and 'endReference' not in already_processed:
            already_processed.append('endReference')
            outfile.write(' endReference=%s' % (self.gds_format_string(quote_attrib(self.endReference).encode(ExternalEncoding), input_name='endReference'),))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'),))
        if self.language is not None and 'language' not in already_processed:
            already_processed.append('language')
            outfile.write(' language=%s' % (self.gds_format_string(quote_attrib(self.language).encode(ExternalEncoding), input_name='language'),))
        if self.avatarUrl is not None and 'avatarUrl' not in already_processed:
            already_processed.append('avatarUrl')
            outfile.write(' avatarUrl=%s' % (self.gds_format_string(quote_attrib(self.avatarUrl).encode(ExternalEncoding), input_name='avatarUrl'),))
        if self.appId is not None and 'appId' not in already_processed:
            already_processed.append('appId')
            outfile.write(' appId=%s' % (self.gds_format_string(quote_attrib(self.appId).encode(ExternalEncoding), input_name='appId'),))
        if self.email is not None and 'email' not in already_processed:
            already_processed.append('email')
            outfile.write(' email=%s' % (self.gds_format_string(quote_attrib(self.email).encode(ExternalEncoding), input_name='email'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='MemberRun', fromsubclass_=False):
        for step_ in self.step:
            step_.export(outfile, level, namespace_, name_='step')
    def hasContent_(self):
        if (
            self.step
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MemberRun'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = "%s",\n' % (self.status,))
        if self.userData is not None and 'userData' not in already_processed:
            already_processed.append('userData')
            showIndent(outfile, level)
            outfile.write('userData = "%s",\n' % (self.userData,))
        if self.endReference is not None and 'endReference' not in already_processed:
            already_processed.append('endReference')
            showIndent(outfile, level)
            outfile.write('endReference = "%s",\n' % (self.endReference,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.language is not None and 'language' not in already_processed:
            already_processed.append('language')
            showIndent(outfile, level)
            outfile.write('language = "%s",\n' % (self.language,))
        if self.avatarUrl is not None and 'avatarUrl' not in already_processed:
            already_processed.append('avatarUrl')
            showIndent(outfile, level)
            outfile.write('avatarUrl = "%s",\n' % (self.avatarUrl,))
        if self.appId is not None and 'appId' not in already_processed:
            already_processed.append('appId')
            showIndent(outfile, level)
            outfile.write('appId = "%s",\n' % (self.appId,))
        if self.email is not None and 'email' not in already_processed:
            already_processed.append('email')
            showIndent(outfile, level)
            outfile.write('email = "%s",\n' % (self.email,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('step=[\n')
        level += 1
        for step_ in self.step:
            showIndent(outfile, level)
            outfile.write('model_.Step(\n')
            step_.exportLiteral(outfile, level, name_='Step')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
            self.validate_MemberStatus(self.status)  # validate type MemberStatus
        value = find_attr_value_('userData', node)
        if value is not None and 'userData' not in already_processed:
            already_processed.append('userData')
            self.userData = value
        value = find_attr_value_('endReference', node)
        if value is not None and 'endReference' not in already_processed:
            already_processed.append('endReference')
            self.endReference = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.append('language')
            self.language = value
        value = find_attr_value_('avatarUrl', node)
        if value is not None and 'avatarUrl' not in already_processed:
            already_processed.append('avatarUrl')
            self.avatarUrl = value
        value = find_attr_value_('appId', node)
        if value is not None and 'appId' not in already_processed:
            already_processed.append('appId')
            self.appId = value
        value = find_attr_value_('email', node)
        if value is not None and 'email' not in already_processed:
            already_processed.append('email')
            self.email = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'step':
            class_obj_ = self.get_class_obj_(child_, Step)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.step.append(obj_)
# end class MemberRun


class MessageFlowRun(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, serviceDisplayEmail=None, serviceData=None, serviceName=None, launchTimestamp=None, serviceEmail=None, definition=None, memberRun=None):
        self.serviceDisplayEmail = _cast(None, serviceDisplayEmail)
        self.serviceData = _cast(None, serviceData)
        self.serviceName = _cast(None, serviceName)
        self.launchTimestamp = _cast(int, launchTimestamp)
        self.serviceEmail = _cast(None, serviceEmail)
        if definition is None:
            self.definition = []
        else:
            self.definition = definition
        if memberRun is None:
            self.memberRun = []
        else:
            self.memberRun = memberRun
    def factory(*args_, **kwargs_):
        if MessageFlowRun.subclass:
            return MessageFlowRun.subclass(*args_, **kwargs_)
        else:
            return MessageFlowRun(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definition(self): return self.definition
    def set_definition(self, definition): self.definition = definition
    def add_definition(self, value): self.definition.append(value)
    def insert_definition(self, index, value): self.definition[index] = value
    def get_memberRun(self): return self.memberRun
    def set_memberRun(self, memberRun): self.memberRun = memberRun
    def add_memberRun(self, value): self.memberRun.append(value)
    def insert_memberRun(self, index, value): self.memberRun[index] = value
    def get_serviceDisplayEmail(self): return self.serviceDisplayEmail
    def set_serviceDisplayEmail(self, serviceDisplayEmail): self.serviceDisplayEmail = serviceDisplayEmail
    def get_serviceData(self): return self.serviceData
    def set_serviceData(self, serviceData): self.serviceData = serviceData
    def get_serviceName(self): return self.serviceName
    def set_serviceName(self, serviceName): self.serviceName = serviceName
    def get_launchTimestamp(self): return self.launchTimestamp
    def set_launchTimestamp(self, launchTimestamp): self.launchTimestamp = launchTimestamp
    def get_serviceEmail(self): return self.serviceEmail
    def set_serviceEmail(self, serviceEmail): self.serviceEmail = serviceEmail
    def export(self, outfile, level, namespace_='mstns:', name_='MessageFlowRun', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessageFlowRun')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='MessageFlowRun'):
        if self.serviceDisplayEmail is not None and 'serviceDisplayEmail' not in already_processed:
            already_processed.append('serviceDisplayEmail')
            outfile.write(' serviceDisplayEmail=%s' % (self.gds_format_string(quote_attrib(self.serviceDisplayEmail).encode(ExternalEncoding), input_name='serviceDisplayEmail'),))
        if self.serviceData is not None and 'serviceData' not in already_processed:
            already_processed.append('serviceData')
            outfile.write(' serviceData=%s' % (self.gds_format_string(quote_attrib(self.serviceData).encode(ExternalEncoding), input_name='serviceData'),))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.append('serviceName')
            outfile.write(' serviceName=%s' % (self.gds_format_string(quote_attrib(self.serviceName).encode(ExternalEncoding), input_name='serviceName'),))
        if self.launchTimestamp is not None and 'launchTimestamp' not in already_processed:
            already_processed.append('launchTimestamp')
            outfile.write(' launchTimestamp="%s"' % self.gds_format_integer(self.launchTimestamp, input_name='launchTimestamp'))
        if self.serviceEmail is not None and 'serviceEmail' not in already_processed:
            already_processed.append('serviceEmail')
            outfile.write(' serviceEmail=%s' % (self.gds_format_string(quote_attrib(self.serviceEmail).encode(ExternalEncoding), input_name='serviceEmail'),))
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='MessageFlowRun', fromsubclass_=False):
        for definition_ in self.definition:
            definition_.export(outfile, level, namespace_, name_='definition')
        for memberRun_ in self.memberRun:
            memberRun_.export(outfile, level, namespace_, name_='memberRun')
    def hasContent_(self):
        if (
            self.definition or
            self.memberRun
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MessageFlowRun'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.serviceDisplayEmail is not None and 'serviceDisplayEmail' not in already_processed:
            already_processed.append('serviceDisplayEmail')
            showIndent(outfile, level)
            outfile.write('serviceDisplayEmail = "%s",\n' % (self.serviceDisplayEmail,))
        if self.serviceData is not None and 'serviceData' not in already_processed:
            already_processed.append('serviceData')
            showIndent(outfile, level)
            outfile.write('serviceData = "%s",\n' % (self.serviceData,))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.append('serviceName')
            showIndent(outfile, level)
            outfile.write('serviceName = "%s",\n' % (self.serviceName,))
        if self.launchTimestamp is not None and 'launchTimestamp' not in already_processed:
            already_processed.append('launchTimestamp')
            showIndent(outfile, level)
            outfile.write('launchTimestamp = %d,\n' % (self.launchTimestamp,))
        if self.serviceEmail is not None and 'serviceEmail' not in already_processed:
            already_processed.append('serviceEmail')
            showIndent(outfile, level)
            outfile.write('serviceEmail = "%s",\n' % (self.serviceEmail,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('definition=[\n')
        level += 1
        for definition_ in self.definition:
            showIndent(outfile, level)
            outfile.write('model_.MessageFlowDefinition(\n')
            definition_.exportLiteral(outfile, level, name_='MessageFlowDefinition')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('memberRun=[\n')
        level += 1
        for memberRun_ in self.memberRun:
            showIndent(outfile, level)
            outfile.write('model_.MemberRun(\n')
            memberRun_.exportLiteral(outfile, level, name_='MemberRun')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('serviceDisplayEmail', node)
        if value is not None and 'serviceDisplayEmail' not in already_processed:
            already_processed.append('serviceDisplayEmail')
            self.serviceDisplayEmail = value
        value = find_attr_value_('serviceData', node)
        if value is not None and 'serviceData' not in already_processed:
            already_processed.append('serviceData')
            self.serviceData = value
        value = find_attr_value_('serviceName', node)
        if value is not None and 'serviceName' not in already_processed:
            already_processed.append('serviceName')
            self.serviceName = value
        value = find_attr_value_('launchTimestamp', node)
        if value is not None and 'launchTimestamp' not in already_processed:
            already_processed.append('launchTimestamp')
            try:
                self.launchTimestamp = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('serviceEmail', node)
        if value is not None and 'serviceEmail' not in already_processed:
            already_processed.append('serviceEmail')
            self.serviceEmail = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'definition':
            obj_ = MessageFlowDefinition.factory()
            obj_.build(child_)
            self.definition.append(obj_)
        elif nodeName_ == 'memberRun':
            obj_ = MemberRun.factory()
            obj_.build(child_)
            self.memberRun.append(obj_)
# end class MessageFlowRun


class contentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if contentType.subclass:
            return contentType.subclass(*args_, **kwargs_)
        else:
            return contentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='mstns:', name_='contentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(unicode(xml_escape(self.valueOf_)).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='contentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='contentType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='contentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contentType


class javascriptCodeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if javascriptCodeType.subclass:
            return javascriptCodeType.subclass(*args_, **kwargs_)
        else:
            return javascriptCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='mstns:', name_='javascriptCodeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='javascriptCodeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(unicode(xml_escape(self.valueOf_)).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='javascriptCodeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='javascriptCodeType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='javascriptCodeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class javascriptCodeType


class contentType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if contentType1.subclass:
            return contentType1.subclass(*args_, **kwargs_)
        else:
            return contentType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='mstns:', name_='contentType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contentType1')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(unicode(xml_escape(self.valueOf_)).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='mstns:', name_='contentType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='mstns:', name_='contentType1', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='contentType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contentType1


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attachment'
        rootClass = Attachment
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attachment'
        rootClass = Attachment
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="Attachment",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attachment'
        rootClass = Attachment
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from gen import *\n\n')
    sys.stdout.write('import gen as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    # import pdb; pdb.set_trace()
    main()


__all__ = [
    "AdvancedOrderCategory",
    "AdvancedOrderItem",
    "AdvancedOrderWidget",
    "AdvancedOrderWidgetStep",
    "Answer",
    "Attachment",
    "BaseMessageStep",
    "BaseSliderWidget",
    "Choice",
    "End",
    "FloatValue",
    "FlowCode",
    "FlowElement",
    "Form",
    "FormMessage",
    "GPSLocationWidget",
    "GPSLocationWidgetStep",
    "MemberRun",
    "Message",
    "MessageFlowDefinition",
    "MessageFlowDefinitionSet",
    "MessageFlowRun",
    "MessageStep",
    "MyDigiPassAddress",
    "MyDigiPassEidAddress",
    "MyDigiPassEidProfile",
    "MyDigiPassProfile",
    "MyDigiPassWidget",
    "MyDigiPassWidgetStep",
    "Outlet",
    "PhotoUploadWidget",
    "PhotoUploadWidgetStep",
    "RangeSliderWidget",
    "RangeSliderWidgetStep",
    "ResultsEmail",
    "ResultsFlush",
    "SelectDateWidget",
    "SelectDateWidgetStep",
    "SelectMultiWidget",
    "SelectMultiWidgetStep",
    "SelectSingleWidget",
    "SelectSingleWidgetStep",
    "SelectWidget",
    "SliderWidget",
    "SliderWidgetStep",
    "Step",
    "TextAutocompleteWidget",
    "TextBlockWidget",
    "TextLineWidget",
    "TextWidget",
    "TextWidgetStep",
    "Value",
    "Widget",
    "WidgetStep",
    "contentType",
    "contentType1",
    "javascriptCodeType"
    ]
